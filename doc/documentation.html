<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- Copyright (c)  2000,2001,2002  Josh Coalson -->
<!-- Permission is granted to copy, distribute and/or modify this document -->
<!-- under the terms of the GNU Free Documentation License, Version 1.1 -->
<!-- or any later version published by the Free Software Foundation; -->
<!-- with no invariant sections. -->
<!-- A copy of the license can be found at http://www.gnu.org/copyleft/fdl.html -->
<HTML>
<HEAD>
	<TITLE>FLAC - documentation</TITLE>
</HEAD>

<BODY MARGINWIDTH="0" MARGINHEIGHT="0" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0" BGCOLOR="#99CC99" TEXT="#000000" LINK="#336699" VLINK="#336699" ALINK="#336699">

<TABLE BORDER=0 WIDTH="100%" CELLPADDING=1 CELLSPACING=0>
	<TR>
		<TD ALIGN="CENTER" BGCOLOR="#000000"><A HREF="http://flac.sourceforge.net/"><IMG SRC="images/logo.jpg" ALIGN=CENTER ALT="FLAC Logo" BORDER=0 HSPACE=0></a></TD>
	</TR>
</TABLE>

<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#99CC99"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="25" ALT=""></TD></TR></TABLE>

<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="2" ALT=""></TD></TR></TABLE>

<TABLE WIDTH="100%" CELLPADDING=0 CELLSPACING=0 BORDER=0>
	<TR>
		<TD ALIGN="CENTER" BGCOLOR="#D3D4C5">
			<TABLE CELLPADDING=0 CELLSPACING=0 BORDER=0>
				<TR>
					<TD HEIGHT=22 BGCOLOR="#D3D4C5" ALIGN=CENTER NOWRAP>&nbsp;&nbsp;<A CLASS="topnav" HREF="index.html">home</A>&nbsp;&nbsp;</TD><TD BGCOLOR="#D3D4C5" ALIGN=CENTER>|</TD>
					<TD           BGCOLOR="#D3D4C5" ALIGN=CENTER NOWRAP>&nbsp;&nbsp;<A CLASS="topnav" HREF="news.html">news</A>&nbsp;&nbsp;</TD><TD BGCOLOR="#D3D4C5" ALIGN=CENTER>|</TD>
					<TD           BGCOLOR="#D3D4C5" ALIGN=CENTER NOWRAP>&nbsp;&nbsp;<A CLASS="topnav" HREF="download.html">download</A>&nbsp;&nbsp;</TD><TD BGCOLOR="#D3D4C5" ALIGN=CENTER>|</TD>
					<TD           BGCOLOR="#D3D4C5" ALIGN=CENTER NOWRAP>&nbsp;&nbsp;<A CLASS="topnav" HREF="features.html">features</A>&nbsp;&nbsp;</TD><TD BGCOLOR="#D3D4C5" ALIGN=CENTER>|</TD>
					<TD           BGCOLOR="#D3D4C5" ALIGN=CENTER NOWRAP>&nbsp;&nbsp;<A CLASS="topnav" HREF="goals.html">goals</A>&nbsp;&nbsp;</TD><TD BGCOLOR="#D3D4C5" ALIGN=CENTER>|</TD>
					<TD           BGCOLOR="#D3D4C5" ALIGN=CENTER NOWRAP>&nbsp;&nbsp;<A CLASS="topnav" HREF="format.html">format</A>&nbsp;&nbsp;</TD><TD BGCOLOR="#D3D4C5" ALIGN=CENTER>|</TD>
					<TD           BGCOLOR="#D3D4C5" ALIGN=CENTER NOWRAP>&nbsp;&nbsp;<A CLASS="topnav" HREF="id.html">id</A>&nbsp;&nbsp;</TD><TD BGCOLOR="#D3D4C5" ALIGN=CENTER>|</TD>
					<TD           BGCOLOR="#D3D4C5" ALIGN=CENTER NOWRAP>&nbsp;&nbsp;<A CLASS="topnav" HREF="comparison.html">comparison</A>&nbsp;&nbsp;</TD><TD BGCOLOR="#D3D4C5" ALIGN=CENTER>|</TD>
					<TD           BGCOLOR="#D3D4C5" ALIGN=CENTER NOWRAP>&nbsp;&nbsp;documentation&nbsp;&nbsp;</TD><TD BGCOLOR="#D3D4C5" ALIGN=CENTER>|</TD>
					<TD           BGCOLOR="#D3D4C5" ALIGN=CENTER NOWRAP>&nbsp;&nbsp;<A CLASS="topnav" HREF="developers.html">developers</A>&nbsp;&nbsp;</TD>
				</TR>
			</TABLE>
		</TD>
	</TR>
</TABLE>

<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="2" ALT=""></TD></TR></TABLE>

<TABLE WIDTH="100%" CELLPADDING=0 CELLSPACING=0 BORDER=0>
	<TR>
		<TD ALIGN="CENTER" BGCOLOR="#EEEED4">
			<TABLE CELLPADDING=0 CELLSPACING=0 BORDER=0>
				<TR>
					<TD HEIGHT=22 BGCOLOR="#EEEED4" ALIGN=CENTER NOWRAP>&nbsp;&nbsp;english&nbsp;&nbsp;</TD><TD BGCOLOR="#EEEED4" ALIGN=CENTER>|</TD>
					<TD           BGCOLOR="#EEEED4" ALIGN=CENTER NOWRAP>&nbsp;&nbsp;<A CLASS="topnav" HREF="ru/documentation.html">russian</A>&nbsp;&nbsp;</TD>
				</TR>
			</TABLE>
		</TD>
	</TR>
</TABLE>

<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="2" ALT=""></TD></TR></TABLE>

<CENTER>

<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#99CC99"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="15" ALT=""></TD></TR></TABLE>


<TABLE WIDTH="100%" CELLPADDING="5" CELLSPACING="5" BORDER="0">
<TR><TD>
	<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="1" ALT=""></TD></TR></TABLE>
	<TABLE CELLSPACING="0" CELLPADDING="3" WIDTH="100%" BORDER="0" BGCOLOR="#D3D4C5">
		<TR><TD><FONT FACE="Lucida,Verdana,Helvetica,Arial">
		<B><FONT SIZE="+2">documentation</FONT></B>
		</FONT></TD></TR>
	</TABLE>
	<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="1" ALT=""></TD></TR></TABLE>
	<TABLE CELLSPACING="0" CELLPADDING="3" WIDTH="100%" BORDER="0" BGCOLOR="#EEEED4">
	<TR><TD><FONT FACE="Lucida,Verdana,Helvetica,Arial">
	<P>
		This page is broken up into the following sections:
		<UL>
			<LI><A HREF="#format">format</A> - the user-level view of the FLAC format (for a more detailed explanation see the <A HREF="format.html">format page</A>).</LI>
			<LI><A HREF="#flac">flac</A> - the usage of the command-line file encoder/decoder <B><TT>flac</TT></B>.</LI>
			<LI><A HREF="#metaflac">metaflac</A> - the usage of the command-line FLAC metadata editor <B><TT>metaflac</TT></B>.</LI>
			<LI><A HREF="#plugins">plugins</A> - documentation for the various input plugins.</LI>
			<LI><A HREF="#libflac">libFLAC API</A> - for developers who want to add FLAC support to their programs.</LI>
			<LI><A HREF="#bugs">bugs</A> - known bugs.</LI>
			<LI><A HREF="#monkey">How to add FLAC support to the Monkey's Audio GUI</A></LI>
		</UL>
	</P>
	<P>
		Keep in mind that the online version of this document will always apply to the latest release.  For older releases, check the documentation included with the release package.
	</P>
	</FONT>
	</TD></TR>
	</TABLE>
	<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="1" ALT=""></TD></TR></TABLE>
</TD></TR>
</TABLE>


<TABLE WIDTH="100%" CELLPADDING="5" CELLSPACING="5" BORDER="0">
<TR><TD>
	<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="1" ALT=""></TD></TR></TABLE>
	<TABLE CELLSPACING="0" CELLPADDING="3" WIDTH="100%" BORDER="0" BGCOLOR="#D3D4C5">
		<TR><TD><FONT FACE="Lucida,Verdana,Helvetica,Arial">
		<A NAME="format"><B><FONT SIZE="+2">format</FONT></B>
		</FONT></TD></TR>
	</TABLE>
	<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="1" ALT=""></TD></TR></TABLE>
	<TABLE CELLSPACING="0" CELLPADDING="3" WIDTH="100%" BORDER="0" BGCOLOR="#EEEED4">
	<TR><TD><FONT FACE="Lucida,Verdana,Helvetica,Arial">
	<P>
		<B><TT>flac</TT></B> has been tuned so that the default options yield a good speed vs. compression tradeoff for many kinds of input.  However, if you are looking to maximize the compression rate or speed, or want to use the full power of FLAC's metadata system, this section is for you.  If not, just skip to the <A HREF="#flac">next section</A>.
	</P>
	<P>
		The basic structure of a FLAC stream is:
		<UL>
			<LI>The four byte string "fLaC"</LI>
			<LI>The <A HREF="format.html#def_STREAMINFO">STREAMINFO</A> metadata block</LI>
			<LI>Zero or more other metadata blocks</LI>
			<LI>One or more audio frames</LI>
		</UL>
	</P>
	<P>
		The first four bytes are to identify the FLAC stream.  The metadata that follows contains all the information about the stream except for the audio data itself.  After the metadata comes the encoded audio data.
	</P>
	<P>
		<B>METADATA</B>
	</P>
	<P>
		FLAC defines several types of metadata blocks (see the <A HREF="format.html">format</A> page for the complete list.  Metadata blocks can be any length and new ones can be defined.  A decoder is allowed to skip any metadata types it does not understand.  Only one is mandatory: the STREAMINFO block.  This block has information like the sample rate, number of channels, etc., and data that can help the decoder manage its buffers, like the minimum and maximum data rate and minimum and maximum block size.  Also included in the STREAMINFO block is the MD5 signature of the <I>unencoded</I> audio data.  This is useful for checking an entire stream for transmission errors.
	</P>
	<P>
		Other blocks allow for padding, seek tables, and application-specific data.  You can see <B><TT>flac</TT></B> options below for adding PADDING blocks or specifying seek points.  FLAC does not require seek points for seeking but they can speed up seeks, or be used for cueing in editing applications.
	<P>
	</P>
		Also, if you have a need of a custom metadata block, you can define your own and request an ID <A HREF="id.html">here</A>.  Then you can reserve a PADDING block of the correct size when encoding, and overwrite the padding block with your APPLICATION block after encoding.  The resulting stream will be FLAC compatible; decoders that are aware of your metadata can use it and the rest will safely ignore it.
	</P>
	<P>
		<B>AUDIO DATA</B>
	</P>
	<P>
		After the metadata comes the encoded audio data.  Audio data and metadata are not interleaved.  Like most audio codecs, FLAC splits the unencoded audio data into blocks, and encodes each block separately.  The encoded block is packed into a frame and appended to the stream.  The reference encoder uses a single block size for the whole stream but the FLAC format does not require it.
	</P>
	<P>
		<B>BLOCKING</B>
	</P>
	<P>
		The block size is an important parameter to encoding.  If it is too small, the frame overhead will lower the compression.  If it is too large, the modeling stage of the compressor will not be able to generate an efficient model.  Understanding FLAC's modeling will help you to improve compression for some kinds of input by varying the block size.  In the most general case, using linear prediction on 44.1kHz audio, the optimal block size will be between 2-6 ksamples.  <B><TT>flac</TT></B> defaults to a block size of 4608 in this case.  Using the fast fixed predictors, a smaller block size is usually preferable because of the smaller frame header.
	</P>
	<P>
		<B>INTER-CHANNEL DECORRELATION</B>
	</P>
	<P>
		In the case of stereo input, once the data is blocked it is optionally passed through an inter-channel decorrelation stage.  The left and right channels are converted to center and side channels through the following transformation: mid = (left + right) / 2, side = left - right.  This is a lossless process, unlike joint stereo.  For normal CD audio this can result in significant extra compression.  <B><TT>flac</TT></B> has two options for this: <TT>-m</TT> always compresses both the left-right and mid-side versions of the block and takes the smallest frame, and <TT>-M</TT>, which adaptively switches between left-right and mid-side.
	</P>
	<P>
		<B>MODELING</B>
	</P>
	<P>
		In the next stage, the encoder tries to approximate the signal with a function in such a way that when the approximation is subracted, the result (called the <I>residual</I>, <I>residue</I>, or <I>error</I>) requires fewer bits-per-sample to encode.  The function's parameters also have to be transmitted so they should not be so complex as to eat up the savings.  FLAC has two methods of forming approximations: 1) fitting a simple polynomial to the signal; and 2) general linear predictive coding (LPC).  I will not go into the details here, only some generalities that involve the encoding options.
	</P>
	<P>
		First, fixed polynomial prediction (specified with <TT>-l 0</TT>) is much faster, but less accurate than LPC.  The higher the maximum LPC order, the slower, but more accurate, the model will be.  However, there are diminishing returns with increasing orders.  Also, at some point (usually around order 9) the part of the encoder that guesses what is the best order to use will start to get it wrong and the compression will actually decrease slightly; at that point you will have to you will have to use the exhaustive search option <TT>-e</TT> to overcome this, which is significantly slower.
	</P>
	<P>
		Second, the parameters for the fixed predictors can be transmitted in 3 bits whereas the parameters for the LPC model depend on the bits-per-sample and LPC order.  This means the frame header length varies depending on the method and order you choose and can affect the optimal block size.
	</P>
	<P>
		<B>RESIDUAL CODING</B>
	</P>
	<P>
		Once the model is generated, the encoder subracts the approximation from the original signal to get the residual (error) signal.  The error signal is then losslessly coded.  To do this, FLAC takes advantage of the fact that the error signal generally has a Laplacian (two-sided geometric) distribution, and that there are a set of special Huffman codes called Rice codes that can be used to efficiently encode these kind of signals quickly and without needing a dictionary.
	</P>
	<P>
		Rice coding involves finding a single parameter that matches a signal's distribution, then using that parameter to generate the codes.  As the distribution changes, the optimal parameter changes, so FLAC supports a method that allows the parameter to change as needed.  The residual can be broken into several <I>contexts</I> or <I>partitions</I>, each with it's own Rice parameter.  <B><TT>flac</TT></B> allows you to specify how the partitioning is done with the <TT>-r</TT> option.  The residual can be broken into 2^<I>n</I> partitions, by using the option <TT>-r n,n</TT>.  The parameter <I>n</I> is called the <I>partition order</I>.  Furthermore, the encoder can be made to search through <I>m</I> to <I>n</I> partition orders, taking the best one, by specifying <TT>-r m,n</TT>.  Generally, the choice of n does not affect encoding speed but m,n does.  The larger the difference between m and n, the more time it will take the encoder to search for the best order.  The block size will also affect the optimal order.
	</P>
	<P>
		<B>FRAMING</B>
	</P>
	<P>
		An audio frame is preceded by a frame header and trailed by a frame footer.  The header starts with a sync code, and contains the minimum information necessary for a decoder to play the stream, like sample rate, bits per sample, etc.  It also contains the block or sample number and an 8-bit CRC of the frame header.  The sync code, frame header CRC, and block/sample number allow resynchronization and seeking even in the absence of seek points.  The frame footer contains a 16-bit CRC of the entire encoded frame for error detection.  If the reference decoder detects a CRC error it will generate a silent block.
	</P>
	<P>
		<B>MISCELLANEOUS</B>
	</P>
	<P>
		In order to support come common types of metadata, the reference decoder knows how to skip ID3V1 and ID3V2 tags so it is safe to tag FLAC files in this way.  ID3V2 tags must come at the beginning of the file (before the "fLaC" marker) and ID3V1 tags must come at the end of the file.
	</P>
	<P>
		<B><TT>flac</TT></B> has a verify option <TT>-V</TT> that verifies the output while encoding.  With this option, a decoder is run in parallel to the encoder and its output is compared against the original input.  If a difference is found <B><TT>flac</TT></B> will stop with an error.
	</P>
	</FONT>
	</TD></TR>
	</TABLE>
	<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="1" ALT=""></TD></TR></TABLE>
</TD></TR>
</TABLE>


<TABLE WIDTH="100%" CELLPADDING="5" CELLSPACING="5" BORDER="0">
<TR><TD>
	<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="1" ALT=""></TD></TR></TABLE>
	<TABLE CELLSPACING="0" CELLPADDING="3" WIDTH="100%" BORDER="0" BGCOLOR="#D3D4C5">
		<TR><TD><FONT FACE="Lucida,Verdana,Helvetica,Arial">
		<A NAME="flac"><B><FONT SIZE="+2">flac</FONT></B>
		</FONT></TD></TR>
	</TABLE>
	<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="1" ALT=""></TD></TR></TABLE>
	<TABLE CELLSPACING="0" CELLPADDING="3" WIDTH="100%" BORDER="0" BGCOLOR="#EEEED4">
	<TR><TD><FONT FACE="Lucida,Verdana,Helvetica,Arial">
	<P>
		<B><TT>flac</TT></B> is the command-line file encoder/decoder.  The input to the encoder and the output to the decoder must either be RIFF WAVE format, or raw interleaved sample data.  <B><TT>flac</TT></B> only supports linear PCM samples (in other words, no A-LAW, uLAW, etc.).  Another restriction (hopefully short-term) is that the input must be 8, 16, or 24 bits per sample.  This is not a limitation of the FLAC format, just the reference encoder/decoder.
	</P>
	<P>
		<B><TT>flac</TT></B> assumes that files ending in ".wav" or that have the RIFF WAVE header present are WAVE files; this may be overridden with a command-line option; it also assumes that files ending in ".ogg" are Ogg-FLAC files.  Other than this, <B><TT>flac</TT></B> makes no assumptions about file extensions, though the convention is that FLAC files have the extension ".flac" (or ".fla" on ancient file systems like FAT-16).
	</P>
	<P>
		Before going into the full command-line description, a few other things help to sort it out: 1) <B><TT>flac</TT></B> encodes by default, so you must use <B>-d</B> to decode; 2) the options <B><TT>-0</TT></B> .. <B><TT>-8</TT></B> that control the compression level actually are just synonyms for different groups of specific encoding options (described later) and you can get the same effect by using the same options; 3) <B><TT>flac</TT></B> behaves similarly to gzip in the way it handles input and output files.
	</P>
	<P>
		<B><TT>flac</TT></B> will be invoked one of four ways, depending on whether you are encoding, decoding, testing, or analyzing:
		<UL>
		<LI>
			Encoding: flac [-s] [--skip #] [-V] [<I><A HREF="#format_options">&lt;format-options&gt;</A></I>] [<I><A HREF="#encoding_options">&lt;encoding options&gt;</A></I>] [inputfile [...]]
		</LI>
		<LI>
			Decoding: flac -d [-s] [--skip #] [<I><A HREF="#format_options">&lt;format-options&gt;</A></I>] [inputfile [...]]
		</LI>
		<LI>
			Testing: flac -t [-s] [inputfile [...]]
		</LI>
		<LI>
			Analyzing: flac -a [-s] [--skip #] [<I><A HREF="#analysis_options">&lt;analysis-options&gt;</A></I>] [inputfile [...]]
		</LI>
		</UL>
	</P>
	<P>
		In any case, if no <TT>inputfile</TT> is specified, stdin is assumed.  If only one inputfile is specified, it may be "-" for stdin.  When stdin is used as input, <B><TT>flac</TT></B> will write to stdout.  Otherwise <B><TT>flac</TT></B> will perform the desired operation on each input file to similarly named output files (meaning for encoding, the extension will be replaced with ".flac", or appended with ".flac" if the input file has no extension, and for decoding, the extension will be ".wav" for WAVE output and ".raw" for raw output).  The original file is not deleted unless --delete-input-file is specified.
	</P>
	<P>
		If you are encoding/decoding from stdin to a file, you should use the -o option like so:
		<UL>
		<LI>
			flac [options] -o outputfile
		</LI>
		<LI>
			flac -d [options] -o outputfile
		</LI>
		</UL>
		which are better than:
		<UL>
		<LI>
			flac [options] &gt; outputfile
		</LI>
		<LI>
			flac -d [options] &gt; outputfile
		</LI>
		</UL>
		since the former allows flac to seek backwards to write the STREAMINFO or RIFF WAVE header contents when necessary.
	</P>
	<P>
		Also, you can force output data to go to stdout using <TT>-c</TT>.
	</P>
	<P>The encoding options affect the compression ratio and encoding speed.  The format options are used to tell <B><TT>flac</TT></B> the arrangement of samples if the input file (or output file when decoding) is a raw file.  If it is a RIFF WAVE file the format options are not needed since they are read from the WAVE header.
	</P>
	<P>
		In test mode, <B><TT>flac</TT></B> acts just like in decode mode, except no output file is written.  Both decode and test modes detect errors in the stream, but they also detect when the MD5 signature of the decoded audio does not match the stored MD5 signature, even when the bitstream is valid.
	</P>
	<P>
	<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="0" BGCOLOR="#EEEED4"><TR><TD>
	<TABLE WIDTH="100%" BORDER="1" BGCOLOR="#EEEED4">
		<TR>
			<TD COLSPAN="2" BGCOLOR="#D3D4C5">
				<A NAME="general_options"><FONT SIZE="+1"><B>General Options</B></FONT></A>
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-H</TT>
			</TD>
			<TD>
				Show the long usage screen.  Running <B><TT>flac</TT></B> without arguments shows the short help screen by default.
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-d</TT>
			</TD>
			<TD>
				Decode (<B><TT>flac</TT></B> encodes by default).  <B><TT>flac</TT></B> will exit with an exit code of <TT>1</TT> (and print a message, even in silent mode) if there were any errors during decoding, including when the MD5 checksum does not match the decoded output.  Otherwise the exit code will be <TT>0</TT>.
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-t</TT>
			</TD>
			<TD>
				Test (same as <B><TT>-d</TT></B> except no decoded file is written).  The exit codes are the same as in decode mode.
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-a</TT>
			</TD>
			<TD>
				Analyze (same as <B><TT>-d</TT></B> except an analysis file is written).  The exit codes are the same as in decode mode.  This option is mainly for developers; the output will be a text file that has data about each frame and subframe.
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-c</TT>
			</TD>
			<TD>
				Write output to stdout
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-s</TT>
			</TD>
			<TD>
				Silent: do not show encoding/decoding statistics.
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-o filename</TT>
			</TD>
			<TD>
				Force the output file name (usually <TT><B>flac</B></TT> just changes the extension).  May only be used when encoding a single file.  May not be used in conjunction with <TT>--output-prefix</T>.
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>--output-prefix string</TT>
			</TD>
			<TD>
				Prefix each output file name with the given string.  This can be useful for encoding/decoding files to a different directory.  Make sure if your string is a path name that it ends with a trailing '<TT>/</TT>' slash.
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>--delete-input-file</TT>
			</TD>
			<TD>
				Automatically delete the input file after a successful encode or decode.  If there was an error (including a verify error) the input file is left intact.
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>--skip #</TT>
			</TD>
			<TD>
				Skip over the first # of samples of the input.  This works for both encoding and decoding, but not testing.
			</TD>
		</TR>
	</TABLE>
	</TD></TR></TABLE>
	</P>
	<P>
	<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="0" BGCOLOR="#EEEED4"><TR><TD>
	<TABLE WIDTH="100%" BORDER="1" BGCOLOR="#EEEED4">
		<TR>
			<TD COLSPAN="2" BGCOLOR="#D3D4C5">
				<A NAME="analysis_options"><FONT SIZE="+1"><B>Analysis Options</B></FONT></A>
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>--a-rtext</TT>
			</TD>
			<TD>
				Includes the residual signal in the analysis file.  This will make the file <B>very</B> big, much larger than even the decoded file.
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>--a-rgp</TT>
			</TD>
			<TD>
				Generates a gnuplot file for every subframe; each file will contain the residual distribution of the subframe.  This will create a <B>lot</B> of files.
			</TD>
		</TR>
	</TABLE>
	</TD></TR></TABLE>
	</P>
	<P>
	<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="0" BGCOLOR="#EEEED4"><TR><TD>
	<TABLE WIDTH="100%" BORDER="1" BGCOLOR="#EEEED4">
		<TR>
			<TD COLSPAN="2" BGCOLOR="#D3D4C5">
				<A NAME="encoding_options"><FONT SIZE="+1"><B>Encoding Options</B></FONT></A>
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>--ogg</TT>
			</TD>
			<TD>
				When encoding, generate Ogg-FLAC output instead of native-FLAC.  Ogg-FLAC streams are FLAC streams wrapped in an Ogg transport layer.  The resulting file should have an '.ogg' extension and will still be decodable by <TT><B>flac</B></TT>.<P>
				When decoding, force the input to be treated as Ogg-FLAC.  This is useful when piping input from stdin or when the filename does not end in '.ogg'.
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>--lax</TT>
			</TD>
			<TD>
				Allow encoder to generate non-Subset files.  The resulting FLAC file may not be streamable, so you should only use this option in combination with custom encoding options meant for archival.  File decoders will still be able play (and seek in) such files.
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>--sector-align</TT>
			</TD>
			<TD>
				Align encoding of multiple CD format WAVE files on sector boundaries.  This option is only allowed when encoding WAVE files, all of which have a 44.1kHz sample rate and 2 channels.  With <TT>--sector-align</TT>, the encoder will align the resulting .flac streams so that their lengths are even multiples of a CD sector (1/75th of a second, or 588 samples).  It does this by carrying over any partial sector at the end of each WAVE file to the next stream.  The last stream will be padded to alignment with zeroes.<P>
				This option will have no effect if the files are already aligned (as is the normally the case with WAVE files ripped from a CD).  <TT><B>flac</B></TT> can only align a set of files given in one invocation of <TT><B>flac</B></TT>.<P>
				<B>WARNING:</B> The ordering of files is important!  If you give a command like '<TT>flac --sector-align *.wav</TT>' the shell may not expand the wildcard to the order you expect.  To be safe you should '<TT>echo *.wav</TT>' first to confirm the order, or be explicit like '<TT>flac --sector-align 8.wav 9.wav 10.wav</TT>'.
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-S { # | X | #x }</TT>
			</TD>
			<TD>
				Include a point or points in a SEEKTABLE:<BR>
				<UL>
				<LI>
					<TT>#&nbsp;</TT> : a specific sample number for a seek point
				</LI>
				<LI>
					<TT>X&nbsp;</TT> : a placeholder point (always goes at the end of the SEEKTABLE)
				</LI>
				<LI>
					<TT>#x</TT> : # evenly spaced seekpoints, the first being at sample 0
				</LI>
				</UL>
				You may use many -S options; the resulting SEEKTABLE will be the unique-ified union of all such values.<BR>
				With no -S options, flac defaults to '-S 100x'.  Use -S- for no SEEKTABLE.<BR>
				<B>NOTE:</B> -S #x will not work if the encoder can't determine the input size before starting.<BR>
				<B>NOTE:</B> if you use -S # and # is >= samples in the input, there will be either no seek point entered (if the input size is determinable before encoding starts) or a placeholder point (if input size is not determinable).<BR>
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-P #</TT>
			</TD>
			<TD>
				  Tell the encoder to write a <TT>PADDING</TT> metadata block of the given length (in bytes) after the <TT>STREAMINFO</TT> block.  <TT>-P 0</TT> implies no <TT>PADDING</TT> block, which is the default.  This is useful if you plan to tag the file later with an <TT>APPLICATION</TT> block; instead of having to rewrite the entire file later just to insert your block, you can write directly over the <TT>PADDING</TT> block.
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-b #</TT>
			</TD>
			<TD>
				Specify the block size in samples.  The default is 1152 for -l 0, otherwise 4608.  Subset streams must use one of 192/576/1152/2304/4608/256/512/1024/2048/4096/8192/16384/32768.  The reference encoder uses the same block size for the entire stream.
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-m</TT>
			</TD>
			<TD>
				Enable mid-side coding (only for stereo streams).  Tends to increase compression by a few percent on average.  For each block both the stereo pair and mid-side versions of the block will be encoded, and smallest resulting frame will be stored.  Currently mid-side encoding is only available when bits-per-sample <= 16.
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-M</TT>
			</TD>
			<TD>
				Enable loose mid-side coding (only for stereo streams).  Like <TT>-m</TT> but the encoder adaptively switches between independent and mid-side coding, which is faster but yields less compression than <TT>-m</TT> (which does an exhaustive search).
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-0 .. -8</TT>
			</TD>
			<TD>
				Fastest compression .. highest compression.  The default is <TT>-5</TT>.
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-0</TT>
			</TD>
			<TD>
				Synonymous with <TT>-l 0 -b 1152 -r 2,2</TT>
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-1</TT>
			</TD>
			<TD>
				Synonymous with <TT>-l 0 -b 1152 -M -r 2,2</TT>
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-2</TT>
			</TD>
			<TD>
				Synonymous with <TT>-l 0 -b 1152 -m -r 3</TT>
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-3</TT>
			</TD>
			<TD>
				Synonymous with <TT>-l 6 -b 4608 -r 3,3</TT>
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-4</TT>
			</TD>
			<TD>
				Synonymous with <TT>-l 8 -b 4608 -M -r 3,3</TT>
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-5</TT>
			</TD>
			<TD>
				Synonymous with <TT>-l 8 -b 4608 -m -r 3,3</TT>
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-6</TT>
			</TD>
			<TD>
				Synonymous with <TT>-l 8 -b 4608 -m -r 4</TT>
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-7</TT>
			</TD>
			<TD>
				Synonymous with <TT>-l 8 -b 4608 -m -e -r 6</TT>
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-8</TT>
			</TD>
			<TD>
				Synonymous with <TT>-l 12 -b 4608 -m -e -r 6</TT>
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-e</TT>
			</TD>
			<TD>
				Exhaustive model search (expensive!).  Normally the encoder estimates the best model to use and encodes once based on the estimate.  With an exhaustive model search, the encoder will generate subframes for every order and use the smallest.  If the max LPC order is high this can significantly increase the encode time but can shave off another 0.5%.
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-E</TT>
			</TD>
			<TD>
				Do escape coding in the entropy coder.  This causes the encoder to use an unencoded representation of the residual in a partition if it is smaller.  It increases the runtime and usually results in an improvement of less than 1%.
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-l #</TT>
			</TD>
			<TD>
				Specifies the maximum LPC order.  This number must be <= 32.  If 0, the encoder will not attempt generic linear prediction, and use only fixed predictors.  Using fixed predictors is faster but usually results in files being 5-10% larger.
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-q #</TT>
			</TD>
			<TD>
				Specifies the precision of the quantized LP coefficients, in bits.  The default is <B><TT>-q 0</TT></B>, which means let the encoder decide based on the signal.  Unless you really know your input file it's best to leave this up to the encoder.
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-p</TT>
			</TD>
			<TD>
				Do exhaustive LP coefficient quantization optimization.  This option overrides any <B><TT>-q</TT></B> option.  It is expensive and typically will only improve the compression a tiny fraction of a percent.  <B><TT>-q</TT></B> has no effect when <B><TT>-l 0</TT></B> is used.
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-r [#,]#</TT>
			</TD>
			<TD>
				Set the [min,]max residual partition order.  The min value defaults to 0 if unspecified.<P>
				By default the encoder uses a single Rice parameter for the subframe's entire residual.  With this option, the residual is iteratively partitioned into 2^min# .. 2^max# pieces, each with its own Rice parameter.  Higher values of max# yield diminishing returns.  The most bang for the buck is usually with <B><TT>-r 2,2</TT></B> (more for higher block sizes).  This usually shaves off about 1.5%.  The technique tends to peak out about when blocksize/(2^n)=128.  Use <B><TT>-r 0,16</TT></B> to force the highest degree of optimization.
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-R #</TT>
			</TD>
			<TD>
				Set the Rice parameter search distance.  Defaults to 0.  The residual coder will search for the best Rice parameter +/- this number for each residual partition.  This option is expensive (run time for -R n will typically be (2n)*30% over that of -R 0) and doesn't give much of a gain.  As a matter of fact, none of the -0..-8 options currently use it since -R > 1 is not consistently better like it should be.
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-V</TT>
			</TD>
			<TD>
				Verify the encoding process.  With this option, <B><TT>flac</TT></B> will create a parallel decoder that decodes the output of the encoder and compares the result against the original.  It will abort immediately with an error if a mismatch occurs.  <B><TT>-V</TT></B> increases the total encoding time but is guaranteed to catch any unforseen bug in the encoding process.
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
			</TD>
			<TD>
				<TT>-S-</TT>, <TT>-m-</TT>, <TT>-e-</TT>, <TT>-E-</TT>, <TT>-p-</TT>, <TT>-V-</TT>, <TT>--delete-input-file-</TT>, <TT>--lax-</TT>, <TT>--sector-align-</TT> can all be used to turn off a particular option.
			</TD>
		</TR>
	</TABLE>
	</TD></TR></TABLE>
	</P>
	<P>
	<TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="0" BGCOLOR="#EEEED4"><TR><TD>
	<TABLE WIDTH="100%" BORDER="1" BGCOLOR="#EEEED4">
		<TR>
			<TD COLSPAN="2" BGCOLOR="#D3D4C5">
				<A NAME="format_options"><FONT SIZE="+1"><B>Format Options</B></FONT></A>
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-fb | -fl</TT>
			</TD>
			<TD>
				Specify big-endian | little-endian byte order in the raw file.
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-fc #</TT>
			</TD>
			<TD>
				Specify the number of channels in the raw file.
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-fp #</TT>
			</TD>
			<TD>
				Specify the number of bits per sample in the raw file.
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-fs #</TT>
			</TD>
			<TD>
				Specify the sample rate of the raw file.
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-fu</TT>
			</TD>
			<TD>
				Specify that the samples in the raw file are unsigned (the default is signed).
			</TD>
		</TR>
		<TR>
			<TD NOWRAP ALIGN="RIGHT" VALIGN="TOP" BGCOLOR="#F4F4CC">
				<TT>-fr</TT>
			</TD>
			<TD>
				Treat the input file (or output file if decoding) as a raw file, regardless of the extension.
			</TD>
		</TR>
	</TABLE>
	</TD></TR></TABLE>
	</P>
	</FONT>
	</TD></TR>
	</TABLE>
	<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="1" ALT=""></TD></TR></TABLE>
</TD></TR>
</TABLE>


<TABLE WIDTH="100%" CELLPADDING="5" CELLSPACING="5" BORDER="0">
<TR><TD>
	<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="1" ALT=""></TD></TR></TABLE>
	<TABLE CELLSPACING="0" CELLPADDING="3" WIDTH="100%" BORDER="0" BGCOLOR="#D3D4C5">
		<TR><TD><FONT FACE="Lucida,Verdana,Helvetica,Arial">
		<A NAME="metaflac"><B><FONT SIZE="+2">metaflac</FONT></B>
		</FONT></TD></TR>
	</TABLE>
	<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="1" ALT=""></TD></TR></TABLE>
	<TABLE CELLSPACING="0" CELLPADDING="3" WIDTH="100%" BORDER="0" BGCOLOR="#EEEED4">
	<TR><TD><FONT FACE="Lucida,Verdana,Helvetica,Arial">
	<P>
		<B><TT>metaflac</TT></B> is the command-line <TT>.flac</TT> file metadata editor.  Right now it just lists the contents of all metadata blocks in a .flac file, but soon it will allow you to insert, delete, and edit blocks.
	</P>
	<P>
		Currently <B><TT>metaflac</TT></B> can be invoked only one way:
		<UL>
		<LI>
			Listing: metaflac [-v] inputfile
		</LI>
		</UL>
	</P>
	<P>
		<TT>inputfile</TT> may be "-" for stdin.  If <TT>-v</TT> is used, you will get verbose output.
	</P>
	</FONT>
	</TD></TR>
	</TABLE>
	<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="1" ALT=""></TD></TR></TABLE>
</TD></TR>
</TABLE>

<A NAME="plugins"></A>
<TABLE WIDTH="100%" CELLPADDING="5" CELLSPACING="5" BORDER="0">
<TR><TD>
	<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="1" ALT=""></TD></TR></TABLE>
	<TABLE CELLSPACING="0" CELLPADDING="3" WIDTH="100%" BORDER="0" BGCOLOR="#D3D4C5">
		<TR><TD><FONT FACE="Lucida,Verdana,Helvetica,Arial">
		<A NAME="xmms_plugin"><B><FONT SIZE="+2">xmms plugin</FONT></B></A>
		</FONT></TD></TR>
	</TABLE>
	<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="1" ALT=""></TD></TR></TABLE>
	<TABLE CELLSPACING="0" CELLPADDING="3" WIDTH="100%" BORDER="0" BGCOLOR="#EEEED4">
	<TR><TD><FONT FACE="Lucida,Verdana,Helvetica,Arial">
	<P>
		All that is necessary is to copy <B><TT>libxmms-flac.so</TT></B> to the directory where XMMS looks for input plugins (usually <B><TT>/usr/lib/xmms/Input</TT></B>).  There is nothing else to configure.  Make sure to restart XMMS before trying to play any <TT>.flac</TT> files.
	</P>
	</FONT>
	</TD></TR>
	</TABLE>
	<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="1" ALT=""></TD></TR></TABLE>
</TD></TR>
</TABLE>


<TABLE WIDTH="100%" CELLPADDING="5" CELLSPACING="5" BORDER="0">
<TR><TD>
	<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="1" ALT=""></TD></TR></TABLE>
	<TABLE CELLSPACING="0" CELLPADDING="3" WIDTH="100%" BORDER="0" BGCOLOR="#D3D4C5">
		<TR><TD><FONT FACE="Lucida,Verdana,Helvetica,Arial">
		<A NAME="winamp2_plugin"><B><FONT SIZE="+2">winamp2 plugin</FONT></B>
		</FONT></TD></TR>
	</TABLE>
	<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="1" ALT=""></TD></TR></TABLE>
	<TABLE CELLSPACING="0" CELLPADDING="3" WIDTH="100%" BORDER="0" BGCOLOR="#EEEED4">
	<TR><TD><FONT FACE="Lucida,Verdana,Helvetica,Arial">
	<P>
		There are two Winamp plugins; one for Winamp versions 2.x and one for Winamp versions 3.x.  If you are using Winamp 2.x, all that is necessary is to copy <B><TT>in_flac.dll</TT></B> to the <B><TT>Plugins/</TT></B> directory of your Winamp installation.  There is nothing else to configure.  Make sure to restart Winamp before trying to play any <TT>.flac</TT> files.
	</P>
	</FONT>
	</TD></TR>
	</TABLE>
	<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="1" ALT=""></TD></TR></TABLE>
</TD></TR>
</TABLE>


<TABLE WIDTH="100%" CELLPADDING="5" CELLSPACING="5" BORDER="0">
<TR><TD>
	<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="1" ALT=""></TD></TR></TABLE>
	<TABLE CELLSPACING="0" CELLPADDING="3" WIDTH="100%" BORDER="0" BGCOLOR="#D3D4C5">
		<TR><TD><FONT FACE="Lucida,Verdana,Helvetica,Arial">
		<A NAME="winamp3_plugin"><B><FONT SIZE="+2">winamp3 plugin</FONT></B>
		</FONT></TD></TR>
	</TABLE>
	<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="1" ALT=""></TD></TR></TABLE>
	<TABLE CELLSPACING="0" CELLPADDING="3" WIDTH="100%" BORDER="0" BGCOLOR="#EEEED4">
	<TR><TD><FONT FACE="Lucida,Verdana,Helvetica,Arial">
	<P>
		There are two Winamp plugins; one for Winamp versions 2.x and one for Winamp versions 3.x.  If you are using Winamp 3.x, all that is necessary is to copy <B><TT>cnv_flacpcm.wac</TT></B> to the <B><TT>Wacs/</TT></B> directory of your Winamp installation.  There is nothing else to configure.  Make sure to restart Winamp before trying to play any <TT>.flac</TT> files.
	</P>
	</FONT>
	</TD></TR>
	</TABLE>
	<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="1" ALT=""></TD></TR></TABLE>
</TD></TR>
</TABLE>


<TABLE WIDTH="100%" CELLPADDING="5" CELLSPACING="5" BORDER="0">
<TR><TD>
	<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="1" ALT=""></TD></TR></TABLE>
	<TABLE CELLSPACING="0" CELLPADDING="3" WIDTH="100%" BORDER="0" BGCOLOR="#D3D4C5">
		<TR><TD><FONT FACE="Lucida,Verdana,Helvetica,Arial">
		<A NAME="libflac"><B><FONT SIZE="+2">libFLAC</FONT></B>
		</FONT></TD></TR>
	</TABLE>
	<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="1" ALT=""></TD></TR></TABLE>
	<TABLE CELLSPACING="0" CELLPADDING="3" WIDTH="100%" BORDER="0" BGCOLOR="#EEEED4">
	<TR><TD><FONT FACE="Lucida,Verdana,Helvetica,Arial">
	<P>
		The FLAC library <B><TT>libFLAC</TT></B> is a C implementation of reference encoders and decoders.  By linking against <B><TT>libFLAC</TT></B> and writing a little code, it is relatively easy to add FLAC support to another program.  The library is licensed under the <A HREF="http://www.gnu.org/copyleft/lesser.html">LGPL</A>.  Complete source code of <B><TT>libFLAC</TT></B> as well as the command-line encoder and plugins is available and is a useful source of examples.
	</P>
	<P>
		<B><TT>libFLAC</TT></B> usually only requires the standard C library and C math library.  In particular, threading is not used so there is no dependency on a thread library.  However, <B><TT>libFLAC</TT></B> does not use global variables and should be thread-safe.
	</P>
	<P>
		The <B><TT>libFLAC</TT></B> interface is described in the public header files in the include/FLAC directory.  The public headers and the compiled library are all that is needed to compile and link against the library.  Note that none of the code in src/libFLAC/, including the private header files in src/libFLAC/include/ is required.
	</P>
	<P>
		The basic usage of <B><TT>libFLAC</TT></B> is as follows:
		<OL>
			<LI>The program creates an instance of a decoder or encoder using <TT>*_new()</TT>.</LI>
			<LI>The program sets the parameters of the instance and callbacks for reading, writing, error reporting, and metadata reporting using <TT>*_set_*()</TT> functions.</LI>
			<LI>The program initializes the instance to validate the parameters and prepare for decoding/encoding using <TT>*_init()</TT>.</LI>
			<LI>The program calls <TT>*_process_*()</TT> functions to encode or decode data, which subsequently calls the callbacks.</LI>
			<LI>The program finishes the instance with <TT>*_finish()</TT>, which flushes the input and output.</LI>
			<LI>The instance may be used again or deleted with <TT>*_delete()</TT>.</LI>
		</OL>
	</P>
	<P>
		For decoding, <B><TT>libFLAC</TT></B> provides three layers of access.  The lowest layer is non-seekable stream-level decoding, the next is seekable stream-level decoding, and the highest layer is file-level decoding.  The interfaces are described in <TT>stream_decoder.h</TT>, <TT>seekable_stream_decoder.h</TT>, and <TT>file_decoder.h</TT> respectively.  Typically you will choose the highest layer that your input source will support.
	</P>
	<P>
		The stream decoder relies on callbacks for all input and output and has no provisions for seeking.  The seekable stream decoder wraps the stream decoder and exposes functions for seeking.  However, you must provide extra callbacks for seek-related operations on your stream, like seek and tell.  The file decoder wraps the seekable stream decoder and supplies most of the callbacks internally, simplifying the processing of standard files.
	</P>
	<P>
		Currently there is only one level of encoder implementation which is at the stream level (<TT>stream_encoder.h</TT>).  There is currently no file encoder because seeking within a file while encoding seemed like too obscure a feature.
	</P>
	<P>
		Structures and constants related to the format are defined in <TT>format.h</TT>.
	</P>
	<P>
		<B>STREAM DECODER</B>
	</P>
	<P>
		First we discuss the stream decoder.  The instance type is <TT>FLAC__StreamDecoder</TT>.  Typically the program will create a new instance by calling <TT>FLAC__stream_decoder_new()</TT>, then call <TT>FLAC__stream_decoder_set_*()</TT> functions to set the callbacks and client data, and call <TT>FLAC__stream_decoder_init()</TT>.  The required callbacks are:
		<UL>
			<LI>Read callback - This function will be called when the decoder needs more input data.  The address of the buffer to be filled is supplied, along with the number of bytes the buffer can hold.  The callback may choose to supply less data and modify the byte count but must be careful not to overflow the buffer.  The callback then returns a status code chosen from FLAC__StreamDecoderReadStatus.</LI>
			<LI>Write callback - This function will be called when the decoder has decoded a single frame of data.  The decoder will pass the frame metadata as well as an array of pointers (one for each channel) pointing to the decoded audio.</LI>
			<LI>Metadata callback - This function will be called when the decoder has decoded a metadata block.  There will always be one STREAMINFO block per stream, followed by zero or more other metadata blocks.  These will be supplied by the decoder in the same order as they appear in the stream and always before the first audio frame.</LI>
			<LI>Error callback - This function will be called whenever an error occurs during decoding.</LI>
		</UL>
	</P>
	<P>
		Once the decoder is initialized, the program will call one of several functions to stimulate the decoding process:
		<UL>
			<LI><B><TT>FLAC__stream_decoder_process_whole_stream()</TT></B> - Tells the decoder to start and continue processing the stream until the read callback says <TT>FLAC__STREAM_DECODER_READ_END_OF_STREAM</TT> or <TT>FLAC__STREAM_DECODER_READ_ABORT</TT>.</LI>
			<LI><B><TT>FLAC__stream_decoder_process_metadata()</TT></B> - Tells the decoder to start processing the stream and stop upon reaching the first audio frame.</LI>
			<LI><B><TT>FLAC__stream_decoder_process_one_frame()</TT></B> - Tells the decoder to process one audio frame and return.  The decoder must have processed all metadata first before calling this function.</LI>
			<LI><B><TT>FLAC__stream_decoder_process_remaining_frames()</TT></B> - Tells the decoder to process all remaining frames.  The decoder must have processed all metadata first but may also have processed frames with <TT>FLAC__stream_decoder_process_one_frame()</TT>.</LI>
		</UL>
	</P>
	<P>
		When the decoder has finished decoding (normally or through an abort), the instance is finished by calling <TT>FLAC__stream_decoder_finish()</TT>, which ensures the decoder is in the correct state and frees memory.  Then the instance may be deleted with <TT>FLAC__stream_decoder_delete()</TT> or initialized again to decode another stream.
	</P>
	<P>
		Note that the stream decoder has no real concept of stream position, it just converts data.  To seek within a stream the callbacks have only to flush the decoder using <TT>FLAC__stream_decoder_flush()</TT> and start feeding data from the new position through the read callback.  The seekable stream decoder does just this.
	</P>
	<P>
		<B>SEEKABLE STREAM DECODER</B>
	</P>
	<P>
		The seekable stream decoder is a wrapper around the stream decoder which also provides seeking capability.  The instance type is <TT>FLAC__SeekableStreamDecoder</TT>.  In addition to the Read/Write/Metadata/Error callbacks of the stream decoder, the user must also provide the following:
		<UL>
			<LI>Seek callback - This function will be called when the decoder wants to seek to an absolute position in the stream.</LI>
			<LI>Tell callback - This function will be called when the decoder wants to know the current absolute position of the stream.</LI>
			<LI>Length callback - This function will be called when the decoder wants to know length of the stream.  The seeking algorithm currently requires that the overall stream length be known.</LI>
			<LI>EOF callback - This function will be called when the decoder wants to know if it is at the end of the stream.  This could be determined from the tell and length callbacks but it may be more expensive that way.</LI>
		</UL>
	</P>
	<P>
		Seeking is exposed through the <TT>FLAC__seekable_stream_decoder_seek_absolute()</TT> method.  At any point after the seekable stream decoder has been initialized, the user can call this function to seek to an exact sample within the stream.  Subsequently, the first time the write callback is called it will contain a (possibly partial) block starting at that sample.
	</P>
	<P>
		The seekable stream decoder also provides MD5 signature checking.  If this is turned on before initialization, <TT>FLAC__seekable_stream_decoder_finish()</TT> will report when the decoded MD5 signature does not match the one stored in the STREAMINFO block.  MD5 checking is automatically turned off if there is no signature in the STREAMINFO block or when a seek is attempted.
	</P>
	<P>
		<B>FILE DECODER</B>
	</P>
	<P>
		The file decoder is a trivial wrapper around the seekable stream decoder meant to simplfy the process of decoding from a standard file.  The instance type is <TT>FLAC__FileDecoder</TT>.  The file decoder supplies all but the Write/Metadata/Error callbacks.  The user needs only to provide the path to the file and the file decoder handles the rest.
	</P>
	<P>
		Like the seekable stream decoder, seeking is exposed through the <TT>FLAC__file_decoder_seek_absolute()</TT> method.  At any point after the file decoder has been initialized, the user can call this function to seek to an exact sample within the file.  Subsequently, the first time the write callback is called it will contain a (possibly partial) block starting at that sample.
	</P>
	<P>
		The file decoder also inherits MD5 signature checking from the seekable stream decoder.  If this is turned on before initialization, <TT>FLAC__file_decoder_finish()</TT> will report when the decoded MD5 signature does not match the one stored in the STREAMINFO block.  MD5 checking is automatically turned off if there is no signature in the STREAMINFO block or when a seek is attempted.
	</P>
	<P>
		<B>STREAM ENCODER</B>
	</P>
	<P>
		The stream encoder functions similarly to the stream decoder, but has fewer callbacks and more options.  The instance type is <TT>FLAC__StreamEncoder</TT>.  Typically the user will create a new instance by calling <TT>FLAC__stream_encoder_new()</TT>, then set the necessary parameters with <TT>FLAC__stream_encoder_set_*()</TT>, and initialize it by calling <TT>FLAC__stream_encoder_init()</TT>.
	</P>
	<P>
		Unlike the decoding process, FLAC encoding has many options that can affect the speed and compression ratio.  When the user calls <TT>FLAC__stream_encoder_init()</TT> the encoder will validate the values, so you should make sure to check the returned state to see that it is FLAC__STREAM_ENCODER_OK.  When setting these parameters you should have some basic knowledge of the format (see the <A HREF="#format">user-level documentation</A> or the <A HREF="format.html">formal description</A>) but the required parameters are summarized here:
		<UL>
			<LI><B><TT>streamable_subset</TT></B> - true to force the encoder to generate a <A HREF="format.html#subset">Subset stream</A>, else false.</LI>
			<LI><B><TT>do_mid_side_stereo</TT></B> - true to try mid-side encoding on stereo input, else false.  <TT>channels</TT> must be 2.</LI>
			<LI><B><TT>loose_mid_side_stereo</TT></B> - true to do adaptive mid-side switching, else false.  <TT>do_mid_side_stereo</TT> must be true.</LI>
			<LI><B><TT>channels</TT></B> - must be &lt;= <TT>FLAC__MAX_CHANNELS</TT>.</LI>
			<LI><B><TT>bits_per_sample</TT></B> - do not give the encoder wider data than what you specify here or bad things will happen.</LI>
			<LI><B><TT>sample_rate</TT></B> - must be &lt;= <TT>FLAC__MAX_SAMPLE_RATE</TT>.</LI>
			<LI><B><TT>blocksize</TT></B> - must be between <TT>FLAC__MIN_BLOCKSIZE</TT> and <TT>FLAC__MAX_BLOCKSIZE</TT>.</LI>
			<LI><B><TT>max_lpc_order</TT></B> - 0 implies encoder will not try general LPC, only fixed predictors; must be &lt;= <TT>FLAC__MAX_LPC_ORDER</TT>.</LI>
			<LI><B><TT>qlp_coeff_precision</TT></B> - must be &gt;= <TT>FLAC__MIN_QLP_COEFF_PRECISION</TT>, or 0 to let encoder select based on blocksize.  In the current imlementation <TT>qlp_coeff_precision</TT>+<TT>bits_per_sample</TT> must be &lt; 32.</LI>
			<LI><B><TT>do_qlp_coeff_prec_search</TT></B> - false to use <TT>qlp_coeff_precision</TT>; true to search around <TT>qlp_coeff_precision</TT> and take best.</LI>
			<LI><B><TT>do_escape_coding</TT></B> - true => search for escape codes in the entropy coding stage for slightly better compression.</LI>
			<LI><B><TT>do_exhaustive_model_search</TT></B> - false to use estimated bits per residual for scoring; true to generate all and take shortest.</LI>
			<LI><B><TT>min_residual_partition_order</TT></B>, <B><TT>max_residual_partition_order</TT></B> - 0 to estimate Rice parameter based on residual variance; &gt; 0 to partition the residual and use parameter for each based on mean; <TT>min_residual_partition_order</TT> and <TT>max_residual_partition_order</TT> specify the min and max Rice partition order.</LI>
			<LI><B><TT>rice_parameter_search_dist</TT></B> - 0 to try only calculated parameter k; else try all [k-<TT>rice_parameter_search_dist</TT>..k+<TT>rice_parameter_search_dist</TT>] parameters and use the best.</LI>
			<LI><B><TT>total_samples_estimate</TT></B> - May be set to 0 if unknown.  Otherwise, set this to the number of samples to be encoded.  This will allow the STREAMINFO block to be more accurate during the first pass in the event that the encoder can't seek back to the beginning of the output file to write the updated STREAMINFO block.</LI>
			<LI><B><TT>seek_table</TT></B> - Optional seek table to prepend; NULL implies no seek table.</LI>
			<LI><B><TT>padding</TT></B> - Size of PADDING block to add (goes after seek table); 0 implies do not add a PADDING block.</LI>
			<LI><B><TT>last_metadata_is_last</TT></B> - The value the encoder will use for the 'is_last' flag of the last metadata block it writes.  In normal usage you would set this to true, but if you will be manually inserting more metadata blocks between the time of the first write callback (when the encoder sends the <TT>fLaC</TT> header and metadata) and the time actual audio encoding starts then set this to false.</LI>
		</UL>
	</P>
	<P>
		The user provides addresses for the following callbacks:
		<UL>
			<LI>Write callback - This function is called anytime there is raw encoded data to write.  It may include metadata mixed with encoded audio frames and the data is not guaranteed to be aligned on frame or metadata block boundaries.</LI>
			<LI>Metadata callback - This function is called once at the end of encoding with the populated STREAMINFO structure.  This is so file encoders can seek back to the beginning of the file and write the STREAMINFO block with the correct statistics after encoding (like minimum/maximum frame size).</LI>
		</UL>
		The call to <TT>FLAC__stream_encoder_init()</TT> currently will also immediately call the write callback with the "fLaC" signature and all the encoded metadata.
	</P>
	<P>
		After initializing the instance, the user may feed audio data to the encoder in one of two ways:
		<UL>
			<LI>Channel separate, through <B><TT>FLAC__stream_encoder_process()</TT></B> - The user will pass an array of pointers to buffers, one for each channel, to the encoder, each of the same length.  The samples need not be block-aligned.</LI>
			<LI>Channel interleaved, through <B><TT>FLAC__stream_encoder_process_interleaved()</TT></B> - The user will pass a single pointer to data that is channel-interleaved (i.e. <TT>channel0_sample0, channel1_sample0, ... , channelN_sample0, channel0_sample1, ...</TT>).  Again, the samples need not be block-aligned but they must be sample-aligned, i.e. the first value should be channel0_sampleX and the last value channelN_sampleY.</LI>
		</UL>
	</P>
	<P>
		When the user is finished encoding data, it calls <TT>FLAC__stream_encoder_finish()</TT>, which causes the encoder to encode any data still in its input pipe, and call the metadata callback with the final encoding statistics.  Then the instance may be deleted with <TT>FLAC__stream_encoder_delete()</TT> or initialized again to encode another stream.
	</P>
	<P>
		<B>MISCELLANEOUS</B>
	</P>
	<P>
		It should be noted that any time an array of pointers to audio data is passed, the channel order currently only has meaning for stereo streams.  Channel 0 corresponds to the left channel and channel 1 corresponds to the right channel.
	</P>
	<P>
		<B>METADATA</B>
	</P>
	<P>
		For programs that write their own APPLICATION metadata, it is advantageous to instruct the encoder to write a PADDING block of the correct size, so that instead of rewriting the whole stream after encoding, the program can just overwrite the PADDING block.  If only the maximum size of the APPLICATION block is known, the program can write a slightly larger padding block, then split it after encoding into an APPLICATION block and a PADDING block.
	</P>
	<P>
		In the case where the size of the APPLICATION block data is known ahead of time, the required size of the padding block can be easily calculated.  If the APPLICATION block data length in bytes (not including the APPLICATION metadata block header) is N bytes, the size given to the FLAC__StreamEncoder instance before initialization is simply N+4.  This accounts for the extra space needed to store the APPLICATION ID.
	</P>
	<P>
		In the case where only the maximum size is known, say, to be N bytes, the required padding size would be N+8.  Four for the APPLICATION ID as before, and four for the extra PADDING block that will fill up the remainder.  At the end of the encoding, when the APPLICATION block data length is known, say, to be M bytes, the original PADDING block would be overwritten with the APPLICATION block and a PADDING block of size N-M.
	</P>
	</FONT>
	</TD></TR>
	</TABLE>
	<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="1" ALT=""></TD></TR></TABLE>
</TD></TR>
</TABLE>


<TABLE WIDTH="100%" CELLPADDING="5" CELLSPACING="5" BORDER="0">
<TR><TD>
	<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="1" ALT=""></TD></TR></TABLE>
	<TABLE CELLSPACING="0" CELLPADDING="3" WIDTH="100%" BORDER="0" BGCOLOR="#D3D4C5">
		<TR><TD><FONT FACE="Lucida,Verdana,Helvetica,Arial">
		<A NAME="bugs"><B><FONT SIZE="+2">known bugs</FONT></B>
		</FONT></TD></TR>
	</TABLE>
	<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="1" ALT=""></TD></TR></TABLE>
	<TABLE CELLSPACING="0" CELLPADDING="3" WIDTH="100%" BORDER="0" BGCOLOR="#EEEED4">
	<TR><TD><FONT FACE="Lucida,Verdana,Helvetica,Arial">
	<P>
		Bug tracking is done on the Sourceforge project page <A HREF="http://sourceforge.net/bugs/?group_id=13478">here</A>.  If you submit a bug, please provide an email contact and/or use the Monitor feature.
	</P>
	</FONT>
	</TD></TR>
	</TABLE>
	<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="1" ALT=""></TD></TR></TABLE>
</TD></TR>
</TABLE>


<TABLE WIDTH="100%" CELLPADDING="5" CELLSPACING="5" BORDER="0">
<TR><TD>
	<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="1" ALT=""></TD></TR></TABLE>
	<TABLE CELLSPACING="0" CELLPADDING="3" WIDTH="100%" BORDER="0" BGCOLOR="#D3D4C5">
		<TR><TD><FONT FACE="Lucida,Verdana,Helvetica,Arial">
		<A NAME="monkey"><B><FONT SIZE="+2">monkey</FONT></B>
		</FONT></TD></TR>
	</TABLE>
	<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="1" ALT=""></TD></TR></TABLE>
	<TABLE CELLSPACING="0" CELLPADDING="3" WIDTH="100%" BORDER="0" BGCOLOR="#EEEED4">
	<TR><TD><FONT FACE="Lucida,Verdana,Helvetica,Arial">
	<P>
		Monkey's Audio comes with a nice GUI that many people are familiar with.  It supports some external encoders, but not FLAC.  However, the FLAC Windows distribution comes with a utility that allows you to replace one the of the supported lossless external codecs with FLAC.  Here's how:
		<UL>
			<LI>Copy <B><TT>flac.exe</TT></B> and <B><TT>flac_ren.exe</TT></B> to the <B><TT>External/</TT></B> directory of the Monkey's Audio installation.</LI>
			<LI>
				Choose a supported encoder to replace:
				<UL>
					<LI>Shorten - copy <B><TT>flac_mac.exe</TT></B> on top of <B><TT>External/shortn32.exe</TT></B></LI>
					<LI>WavPack - copy <B><TT>flac_mac.exe</TT></B> on top of both <B><TT>External/wavpack.exe</TT></B> and <B><TT>External/wvunpack.exe</TT></B></LI>
					<LI>RKAU - copy <B><TT>flac_mac.exe</TT></B> on top of <B><TT>External/rkau.exe</TT></B></LI>
				</UL>
				If you choose WavPack you will also be able to use the WavPack Configuration menu to add flac options.
			</LI>
			<LI>Now you can encode FLAC files as if you were using the replaced encoder.  The renamed <B><TT>flac_mac.exe</TT></B> utility will call <B><TT>flac.exe</TT></B> and afterwards, <B><TT>flac_ren.exe</TT></B> will rename the resulting file to have the .flac extension.</LI>
		</UL>
	</P>
	<P>
		If you like this little hack, make sure to <A HREF="mailto:email@monkeysaudio.com">ask Matt</A> (the author) to add FLAC support officially!  Also, other front-ends may be wedged in the same way; if you have one in mind, post it to the flac-dev mailing list.
	</P>
	</FONT>
	</TD></TR>
	</TABLE>
	<TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="0"><TR BGCOLOR="#000000"><TD><IMG SRC="images/1x1.gif" WIDTH="1" HEIGHT="1" ALT=""></TD></TR></TABLE>
</TD></TR>
</TABLE>


</CENTER>

<P>&nbsp;Copyright (c) 2000,2001,2002 Josh Coalson</P>

</BODY>
</HTML>
