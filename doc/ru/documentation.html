<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<!-- Copyright (c) 2000,2001,2002  Josh Coalson -->
<!-- Permission is granted to copy, distribute and/or modify this document -->
<!-- under the terms of the GNU Free Documentation License, Version 1.1 -->
<!-- or any later version published by the Free Software Foundation; -->
<!-- with no invariant sections. -->
<!-- A copy of the license can be found at http://www.gnu.org/copyleft/fdl.html -->
<HTML>
<HEAD>
<META CHARSET="windows-1251">
<TITLE>FLAC: документация</TITLE>
</HEAD>

<BODY>
<CENTER><TABLE cellpadding=0 cellspacing=0 border=0>
<TR>
<TD align=center>|</TD>
<TD height=22 align=center nowrap>
&nbsp;<A HREF="index.html">начало</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;<A HREF="news.html">новости</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;<A HREF="download.html">файлы</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;<A HREF="features.html">характеристики</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;<A HREF="goals.html">цели</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;<A HREF="format.html">формат</A>&nbsp;</TD>
<TD align=center>|</TD></TR>

<TR>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;<A HREF="id.html">id</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;<A HREF="comparison.html">сравнение</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;<A HREF="developers.html">разработка</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;документация&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;<A HREF="links.html">ссылки</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;<A HREF="authors.html">авторы</A>&nbsp;</TD>
<TD align=center>|</TD></TR>
</TABLE></CENTER>

<P><CENTER><TABLE cellpadding=0 cellspacing=0 border=0>
<TR><TD align=center>|</TD>
<TD height=22 align=center nowrap>
&nbsp;<A HREF="../documentation.html">english</A>&nbsp;</TD>
<TD align=center>|</TD>
<TD align=center nowrap>
&nbsp;русский</A>&nbsp;</TD>
<TD align=center>|</TD></TR>
</TABLE></CENTER></P>


<CENTER><H2>FLAC: документация</H2></CENTER>

<H3>Документация</H3>

<P>Эта страница разбита на следующие разделы:</P>

<UL>
	<LI><A HREF="#format">формат</A> - описание формата FLAC для пользователя (более детальное описание для разработчика приведено на <A HREF="format.html">этой</A> странице).</LI>
	<LI><A HREF="#flac"><B><TT>flac</TT></B></A> - иcпользование кодека <B><TT>flac</TT></B>, работающего из командной строки.</LI>
	<LI><A HREF="#metaflac"><B><TT>metaflac</TT></B></A> - использование редактора метаданных <B><TT>metaflac</TT></B>, работающего из командной строки.</LI>
	<LI><A HREF="#plugins">плагины</A> - документация для различных плагинов.</LI>
	<LI><A HREF="#libflac">API для <B><TT>libFLAC</TT></B></A> - для разработчиков, желающих использовать поддержку FLAC в своих продуктах.</LI>
	<LI><A HREF="#bugs">ошибки</A> - известные ошибки.</LI>
	<LI><A HREF="#monkey">как добавить поддержку FLAC в Monkey's Audio GUI</A></LI>
</UL>

<P>Помните, что онлайновая версия этого документа (на английском языке) включается в последний релиз.</P>

<A NAME="format">
<H3>Формат</H3>

<P>Опции по умолчанию для <B><TT>flac</TT></B> настроены на получение оптимального соотношения скорость/уровень сжатия для большинства типов входных файлов. Здесь описывается как можно попытаться увеличить уровень или скорость сжатия или с наибольшим эффектом использовать систему метаданных.</P>

<P>Основными частями потока являются:</P>

<P><BLOCKQUOTE><UL>
   <LI>Строка из четырех байтов &quot;fLaC&quot;.</LI>

   <LI>Блок метаданных <A HREF="format.html#def_STREAMINFO">STREAMINFO</A>.</LI>

   <LI>Другие необязательные блоки метаданных.</LI>

   <LI>Один или более аудио фреймов.</LI>
</UL></BLOCKQUOTE></P>

<P>Первые четыре байта идетифицируют поток FLAC. Следующие за ними метаданные содержат информацию о потоке, затем идут сжатые аудиоданные.</P>

<A NAME="metaflac">
<H4>Метаданные</H4>

<P>FLAC определяет несколько типов блоков метаданных (все они перечислены на странице <A HREF="format.html">формат</A>). Блоки метаданных могут быть любого размера, новые блоки могут быть легко добавлены. Декодер имеет возможность пропускать неизветные ему блоки метаданных. Обязателен только блок STREAMINFO. В нем содержится частота дискретизация, количество каналов и т.п., а также данные позволяющие декодеру настроить буфферы. Сюда также записывается подпись MD5 <I>несжатых</I> аудиоданных. Это полезно для проверки всего потока после его передачи.</P>

<P>Другие блоки предназначены для резервирования места, хранения таблиц точек поиска, а также данных для конкретных приложений. Опции для добавления блоков PADDING или точек поиска приведены ниже. FLAC не нуждается в точках поиска, однако они позволяют значительно увеличить скорость доступа, а также могут быть использования для расстановки меток в аудио редакторах.</P>

<P>Если Вам нужен собственный блок метаданных, Вы можете определить его и запросить идентификатор <A HREF="id.html">здесь</A>. Вы можете зарезервировать блок PADDING необходимого размера и записать на его место свои данные после кодирования. Полученнный поток будет отвечать формату FLAC, декодеры распознающие эти блоки смогут их использовать, остальные будут их пропускать.</P>


<H4>Аудиоданные</H4>

<P>За метаданным следуют сжатые аудиоданные. Метаданные и аудиоданные не чередуются. Как и большинство кодеков FLAC делит входной поток на блоки и кодирует их независимо друг от друга. Блок упаковыватся во фрейм и добавляется к потоку. Базовый кодер использует блоки постоянного размера для всего потока, однако формат предусматривает наличие блоков разной длины в потоке.</P>


<H4>Разбиение на блоки</H4>

<P>Размер блока - очень важный параметр для кодирования. Если он очень мал, то в потоке будет слишком заголовков фреймов, что уменьшит уровень сжатия. Если размер большой, то кодер не сможет подобрать эффективную модель сжатия. Понимание процесса моделирования поможет Вам увеличить уровень сжатия для некоторых типов входных данных. Обычно при использовании линейного прогнозирования на аудиоданных с частотой дискретизации 44.1 кГц оптимальный размер блока лежит в диапазоне 2-6 тысяч сэмплов. В этом случае значение по умолчанию - 4608. Если использовать быстрые постоянные предикторы, предпочтительнее меньшие размеры блоков, так как в этом случае размеры заголовков фреймов меньше.</P>


<H4>Межканальная декорреляция</H4>

<P>Если на вход поступают стерео аудиоданные, они могут пройти через стадию межканальной декорреляции. Правый и левый канал преобразуются к среднему и разностному по формулам: <TT>средний = (левый + правый)/2</TT>, <TT>разностный = левый - правый</TT>. В отличие от joint stereo этот процесс не приводит к потерям. Для данных с аудио компакт-дисков это обычно приводит к значительному увеличению уровня сжатия. Для включения использования этого метода кодирования <B><TT>flac</TT></B> имеет две опции: <TT>-m</TT> всегда делает разностную и независимую версию блока и выбирает наименьший фрейм и <TT>-M</TT>, которая адаптивно выбирает схему сжатия.</P>


<H4>Моделирование</H4>

<P>На следующем этапе кодер пытается аппроксимировать сигнал такой функцией, чтобы полученный после ее вычитания из оригинала результат (называемый разностью, остатком, ошибкой) можно было закодировать минимальным количеством битов. Параметры функций тоже должны записываться, поэтому они не должны занимать много места. FLAC использует два метода формирования аппроксимаций: 1) подгонка простого полинома к сигналу и 2) общее кодирование с линейными предикторами (LPC).</P>

<P>Во-первых, постоянное полиномиальное предсказание (<TT>-l 0</TT>) работает значительно быстрее, но менее точно, чем LPC. Чем выше порядок LPC, тем медленнее, но лучше будет модель. Однако с увеличением порядка выигрыш будет все менее значительным. В некоторой точке (обычно около 9) процедура кодера, определяющая наилучший порядок, начинает ошибаться и размер получаемых фреймов возрастает. Чтобы преодолеть это, можно использовать полный перебор (опция <TT>-e</TT>), что приведет к значительному увеличению времени кодирования.</P>

<P>Во-вторых, параметры для постоянных предикторов могут быть описаны тремя битами, а параметры для модели LPC зависят от количества бит на сэмпл и порядка LPC. Это значит, что размер заголовка фрейма зависит от выбранного метода и порядка и может повлиять на оптимальный размер блока.</P>


<H4>Остаточное кодирование</H4>

<P>Когда модель подобрана, кодер вычитает приближение из оригинала, чтобы получить остаточный (ошибочный) сигнал, который затем кодируется без потерь. Для этого используется то обстоятельство, что разностный сигнал обычно имеет распределение Лапласа и есть набор специальный кодов Хаффмана, называемые кодами Райса, позволяющие эффективно и быстро кодировать эти сигналы без использования словаря.</P>

<P>Кодирование Райса состоит из нахождения одного параметра, отвечающего распределению сигнала, а затем использования его для составления кодов. При изменении распределения меняется и оптимальный параметр, поэтому имеется метод позволяющий пересчитывать его по необходимости. Остаток может быть разбит на <I>контексты</I> или <I>разделы</I>, у каждого из которых будет свой параметр Райса. <B><TT>flac</TT></B> позволяет указать, как нужно производить разбиение, с помощью опции <TT>-r</TT>. Остаток может быть разбит на <I>2^n</I> раздела, если использовать <TT>-r n,n</TT>. Параметр <I>n</I> называется порядком раздела. Также кодер может искать в пределах от <I>m</I> до <I>n</I> порядка, выбирая лучший вариант, если указать <TT>-r m,n</TT>. Обычно выбор <I>n</I> не влияет на скорость кодирования. От разницы между <I>m</I> и <I>n</I> сильно зависит время работы, чем она больше, тем больше времени будет затрачиваться на поиск лучшего порядка. Выбор размера блока также влияет на оптимальный порядок раздела.</P>


<H4>Составление фреймов</H4>

<P>Аудиофрейму предшествует заголовок, который начинается с кода синхронизации и содержит минимум информации, необходимой декодеру для воспроизведения потока. Сюда также записывается номер блока или сэмпла и восьмибитная контрольная сумма самого заголовка. Код синхронизации, CRC заголовка фрейма и номер блока/сэмпла позволяют осуществлять пересинхронизацию и поиск даже в отсутствие точек поиска. В конце фрейма записывается его шестнадцатибитная контрольная сумма. Если базовый декодер обнаружит ошибку, будет сгенерирован блок тишины.</P>


<H4>Разное</H4>

<P>Чтобы поддерживать основные типы метаданных, базовый декодер умеет пропускать теги ID3V1 и ID3V2, поэтому их можно свободно добавлять. Теги ID3V2 должны располагаться перед маркером &quot;fLaC&quot;, а теги ID3V1 - в конце файла.</P>

<P>У <B><TT>flac</TT></B> есть опция (<TT>-V</TT>) для проверки выходных данных при кодировании. В этом случае декодер работает одновременно с кодером и его выход сравнивается с оригинальным вводом. Если будет найдено отличие, <B><TT>flac</TT></B> закончит работу с сообщением об ошибке.</P>


<A NAME="flac">
<H3><B><TT>flac</TT></B></H3>

<P><B><TT>flac</TT></B> - это кодек, работающий из командной строки. Входом для кодера и выходом для декодера должен быть либо данные в формате RIFF WAVE, либо поток сэмплов без заголовка. <B><TT>flac</TT></B> использует только линейные PCM сэмплы (другими словами, A-LAW, uLAW, и т.п. не поддерживаются). Следующим ограничением является то, что во кодируемом файле сэмплы должны быть 8, 16 или 24-битными. Это не ограничение формата, просто так работают базовый кодер и декодер.</P>

<P><B><TT>flac</TT></B> предполагает, что файлы RIFF WAVE имеют суффикс ".wav"; это умолчание может быть переопределено специальным ключом. Также предполагается, что файлы с суффиком ".ogg" имеют формат Ogg-FLAC. В остальных случаях <B><TT>flac</TT></B> не делает предположений о суффиксах, хотя по соглашению файлы FLAC имеют суффикс ".flac" (или ".fla" на старых файловых системах таких как FAT-16).</P>

<P>Перед полным описанием ключей, используемых <B><TT>flac</TT></B>, обратим внимание на то что: 1) по умолчанию <B><TT>flac</TT></B> сжимает файлы (для декодирования используйте ключ <TT>-d</TT>); 2) ключи <TT>-0..-8</TT>, а также <TT>--fast</TT> и <TT>--best</TT>, управляющие уровнем сжатия, являются синонимами для различных групп настроек кодирования. Того же эффекта можно добиться, используя наборы соответствующих ключей; 3) модель обработки входных и выходных файлов у <B><TT>flac</TT></B> аналогична <B><TT>gzip</TT></B>.</P>

<P><B><TT>flac</TT></B> вызывается одним из четырех способов:</P>

<BLOCKQUOTE><UL>
    <LI>Кодирование:<BR><TT>flac [-s] [--skip #] [<I><A HREF="#format_options">&lt;настройки_формата&gt;</A></I>] [<I><A HREF="#encoding_options">&lt;опции_кодирования&gt;</A></I>] [входной_файл [...]]</TT></LI>

    <LI>Декодирование:<BR><TT>flac -d [-s] [--skip #] [-F] [<I><A HREF="#format_options">&lt;настройки_формата&gt;</A></I>] [<I><A HREF="#encoding_options">&lt;опции_кодирования&gt;</A></I>] [входной_файл [...]]</TT></LI>

    <LI>Тестирование:<BR><TT>flac -t [-s] [входной_файл [...]]</TT></LI>

    <LI>Анализ:<BR><TT>flac -a [-s] [--skip #] [<I><A HREF="#analysis_options">&lt;опции_анализа&gt;</A></I>] [входной_файл [...]]</TT></LI>
</UL></BLOCKQUOTE></P>

<P>В любом случае, если входной файл не указан, подразумевается стандартный ввод. Если указан только один входной файл, то это может быть "-" для стандартного ввода (stdin). Когда используется стандартный ввод, <B><TT>flac</TT></B> пишет в стандартный вывод (stdout).  В остальных случаях <B><TT>flac</TT></B> выполнит указанные действия для каждого входного файла и запишет результаты в файлы с аналогичными именами (при кодировании суффикс будет заменен на ".flac" или, если его не было, будет добавлен; при декодировании суффиксы также изменяются в соответствии с типом выходных данных.) Оригинал удаляется, только если указан ключ <TT>--delete-input-file</TT>.</P>

<P>Существуют особые формы вызова процедур кодирования/декодирования из стандандартного ввода в файл.</P>

<P><BLOCKQUOTE>
<UL>
    <LI><TT>flac [опции] - выходной_файл</TT></LI>

    <LI><TT>flac -d [опции] - выходной_файл</TT></LI>
</UL>

<P>которые лучше чем</P>

<UL>
    <LI><TT>flac [опции] &gt; выходной_файл</TT></LI>

    <LI><TT>flac -d [опции] &gt; выходной_файл</TT></LI>
</UL>
</BLOCKQUOTE></P>

<P>так как в первом случае сохраняется возможность произвести при необходимости последующую обработку файла, например для записи заголовков <TT>RIFF WAVE</TT> или <TT>STREAMINFO</TT>.</P>

<P>Данные в стандартный вывод можно перенаправить с помощью ключа <TT>-c</TT>.</P>

<P>Опции кодирования влияют на скорость работы и уровень сжатия. Настройки формата определяют расположение сэмплов, если на вход поступает файл без заголовка. Если у файла есть заголовок <TT>RIFF WAVE</TT>, то настойки формата не нужны, так как они берутся из файла.</P>

<P>В режиме тестирования <B><TT>flac</TT></B> работает как и при декодировании, только выходной файл не записывается. Режимы декодирования и тестирования проверяют поток на наличие ошибок, а также сравнивают подпись MD5 декодированного потока с сохраненной подписью, даже если формат потока правильный.</P>

<H4><a name="general_options">Основные ключи</A></H4>
<TABLE border=1>

<TR><TD width=25%><TT>-d</TT></TD>
<TD width=75%>Декодирование (по умолчанию <B><TT>flac</TT></B> кодирует). <B><TT>flac</TT></B> завершит работу с кодом выхода <TT>1</TT>, если будет встречена ошибка или контрольная сумма MD5 декодированного потока не совпадет с сохраненной. Если ошибок не будет, код возврата будет равен <TT>0</TT>.</TD></TR>

<TR><TD><TT>-H</TT></TD>
<TD>Вывести справку полностью. При запуске <B><TT>flac</TT></B> без аргументов отображается краткая справка.</TD></TR>

<TR><TD><TT>-t</TT></TD>
<TD>Тестирование (то же самое, что и декодирование, только выход не записывается в файл). Коды возврата те же.</TD></TR>

<TR><TD><TT>-a</TT></TD>
<TD>Анализ (то же самое, что и декодирование, только выходом является файл статистики). Коды возврата те же.  Режим предназначен в основном для разработчиков. В выходной текстовый файл записывается информация о каждом фрейме и подфрейме.</TD></TR>

<TR><TD><TT>-c</TT></TD>
<TD>Направить результат в стандартный вывод (stdout).</TD></TR>

<TR><TD><TT>-s</TT></TD>
<TD>Не показывать статистику при кодировании/декодировании.</TD></TR>

<TR><TD><TT>-o файл</TT></TD>
<TD>Явно указать имя выходного файла, по умолчанию <B><TT>flac</TT></B> просто заменяет суффикс.</TD></TR>

<TR><TD><TT>--output-prefix строка</TT></TD>
<TD>Добавляет префикс к каждому имени выходному файлу. Может имспользоваться для кодирования/декодирования файлов в другой каталог. Если указанная строка является частью пути, убедитесь, что она заканчивается слэшем '/'.</TD></TR>

<TR><TD><TT>--delete-input-file</TT></TD>
<TD>После успешного окончания кодирования/декодирования входной файл будет удален. Если произойдет ошибка, исходный файл останется.</TD></TR>

<TR><TD><TT>--skip #</TT></TD>
<TD>Пропустить первые <TT>#</TT> сэмплов входного файла. Работает для кодирования и декодирования, но не для тестирования.</TD></TR>
</TABLE>


<H4><a name="analysis_options">Опции анализа</H4>
<TABLE border=1>
<TR><TD width=15%><TT>--a-rtext</TT></TD>
<TD width=85%>Добавляет в файл остаточный сигнал. Результирующий файл получается <B>очень большим</B>.</TD></TR>

<TR><TD width=10%><TT>--a-rgp</TT></TD>
<TD width=90%>Создает файлы-диаграммы для каждого подфрейма. В каждом файле будет остаточное распределение для подфрейма. Будет создано <B>очень много</B> файлов.</TD></TR>
</TABLE>

<H4><a name="decoding_options">Опции декодирования</H4>
<TABLE border=1>
<TR><TD width=15%><TT>-F</TT></TD>
<TD width=85%>По умолчанию <B><TT>flac</TT></B> прекращает декодирование
в случае ошибки в потоке и удаляет частично декодированный файл.
Использование ключа <TT>-F</TT> ведет к тому, что сообщения об ошибках
выводятся, но <B><TT>flac</TT></B> продолжает работу до конца.
Обратите внимание, что в результате такого декодирования в выходном файле
могут быть пропущены сэмплы или появится блоки тишины.</TD></TR>
</TABLE>

<H4><a name="encoding_options">Опции кодирования</A></H4>
<TABLE border=1>

<TR><TD width=15%><TT>--ogg</TT></TD>
<TD width=85%>
<P>При кодировании генерируется вывод в формате Ogg-FLAC вместо "родного"FLAC. Потоки Ogg-FLAC представляют собой потоки FLAC обернутые в транспортный уровень Ogg. Полученный файл будет иметь суффикс '.ogg' и будет декодироваться утилитой <TT><B>flac</B></TT>.</P>
<P>При декодировании формат ввода однозначно определяется как Ogg-FLAC. Это полезно при получении данных со стандартного ввода или если у файла суффикс не '.ogg'.</P></TD></TR>

<TR><TD><TT>--lax</TT></TD>
<TD>Позволяет кодеру создавать файлы, отвечающие подмножеству формата FLAC. В результате работы будет получаться непотоковый файл, поэтому этот ключ следует использовать только для архивирования. Декодер будет поддерживать воспроизведение и поиск в таких файлах.</TD></TR>

<TR><TD><TT>--sector-align</TT></TD>
<TD>
<P>При кодировании нескольких WAVE файлов формата CD-Audio выравнивать их на границу сектора. Эта опция применима только для кодирования нескольких WAVE файлов, каждый из которых должен иметь частоту дискретизации 44.1 кГц и два канала. Если будет указана эта опция кодер выровняет потоки .flac так,
что их длины будут кратны размеру сектора CD-Audio (равны 1/75 секундам или 588 сэмплам). Это осуществляется переносом части сектора в конце каждого WAVE файла в начало следующего. Последний поток будет дополнен до границы выравнивания нулями.</P>
<P>Использование этой опции не приведет ни к чему, если файлы уже выровнены (например, если правильно скопированы с аудио-CD). <TT><B>flac</B></TT> может выровнять только несколько файлов за один вызов.</P>

<P><B>ВНИМАНИЕ</B>: Порядок файлов имеет значение! Если вы сделаете следующий вызов '<TT>flac --sector-align *.wav</TT>', командный процессор может обработать шаблон не в том порядке, в каком вы рассчитываете. Поэтому лучше всего вызывать программу, явно указав список файлов, например, '<TT>flac --sector-align 8.wav 9.wav 10.wav</TT>'. 
</TD></TR>

<TR><TD><TT>-S {#|X|#x}</TT></TD>
<TD width=90%>Добавляет точки для поиска в таблицу <TT>SEEKTABLE</TT>.

<UL>
    <LI><TT>#&nbsp;</TT> : создается точка поиска для сэмпла с определенным номером.</LI>
    
    <LI><TT>X&nbsp;</TT> : резервируемые точки (всегда помещаются в конце <TT>SEEKTABLE</TT>).</LI>
    
    <LI><TT>#x</TT> : # равномерно распределенных точек поиска, первая соответствует 0 сэмплу.</LI>
</UL>

<P>Опцию <TT>-S</TT> можно использовать несколько раз. В результате получится объединенная таблица, в которой будут присутствовать только уникальные значения.<BR>
По умолчанию <B><TT>flac</TT></B> использует <TT>-S 100x</TT>. Если таблица поиска не нужна, укажите <TT>-S-</TT>.<BR>
<B>ПРИМЕЧАНИЕ</B>: <TT>-S #x</TT> не будет работать, если кодер не сможет определить размер входного файла в начале работы.<BR>
<B>ПРИМЕЧАНИЕ</B>: если <I>#</I> больше или равен количеству сэмплов во входном файле, то точки добавлены не будут, если размер можно определить до кодирования, в противном случае будут записаны резервируемые точки.</P>
</TD></TR>

<TR><TD><TT>-P #</TT></TD>
<TD>Eнкодер запишет блок метаданных <TT>PADDING</TT>, указанного размера (в байтах), после блока <TT>STREAMINFO</TT>. Ключи <TT>-P 0</TT> или <TT>-P-</TT> указывают, что блок <TT>PADDING</TT> не нужен (значение по умолчанию). Этот блок полезен, если вы собираетесь добавить тэг в файл позже. Вместо того, чтобы переписывать файл полностью, можно будет записать информацию вместо блока <TT>PADDING</TT>. Обратите внимание на то, что общий размер блока <TT>PADDING</TT> будет на 4 байта больше, так как 4 байта занимает заголовок.</TD></TR>

<TR><TD><TT>-b #</TT></TD>
<TD>Устанавливает размер блока в сэмплах. По умолчанию <TT>1152</TT> для <TT>-l 0</TT>, иначе <TT>4608</TT>. Стандартные потоки должны использовать одно из указаных значений: <TT>192/576/1152/2304/4608/256/512/1024/2048/4096/8192/16384/32768</TT>. Сейчас кодер использует постоянный размер блока для всего файла.</TD></TR>

<TR><TD><TT>-m</TT></TD>
<TD>Включает разностное кодирование (только для стерео потоков). Обычно увеличивает уровень сжатия на несколько процентов. Для каждого блока создается усредненная и стерео версия блока, сохраняется блок меньшего размера. Сейчас разностное кодирование доступно для файлов, где сэмпл имеет размер не больше 16 бит.</TD></TR>

<TR><TD><TT>-M</TT></TD>
<TD>Включает свободное разностное кодирование (только для стерео потоков). Работает аналогично <TT>-m</TT>, однако кодер переключается между независимым и усредняющим кодированием адаптивно. Метод работает быстрее, но уровень сжатия меньше, так как <TT>-m</TT> производит полный перебор вариантов.</TD></TR>

<TR><TD><TT>-0..-8</TT></TD>
<TD>Быстрейшее сжатие ... максимальное сжатие. По умолчанию <TT>-5</TT>.</TD></TR>

<TR><TD><TT>-0</TT></TD>
<TD>Аналогично <TT>-l 0 -b 1152 -r 2,2</TT>.</TD></TR>

<TR><TD><TT>-1</TT></TD>
<TD>Аналогично <TT>-l 0 -b 1152 -r 2,2 -M</TT>.</TD></TR>

<TR><TD><TT>-2</TT></TD>
<TD>Аналогично <TT>-l 0 -b 1152 -r 3 -m</TT>.</TD></TR>

<TR><TD><TT>-3</TT></TD>
<TD>Аналогично <TT>-l 6 -b 4608 -r 3,3</TD></TR>

<TR><TD><TT>-4</TT></TD>
<TD>Аналогично <TT>-l 8 -b 4608 -r 3,3 -M</TT>.</TD></TR>

<TR><TD><TT>-5</TT></TD>
<TD>Аналогично <TT>-l 8 -b 4608 -r 3,3 -m</TT>.</TD></TR>

<TR><TD><TT>-6</TT></TD>
<TD>Аналогично <TT>-l 8 -b 4608 -r 4 -m</TT>.</TD></TR>

<TR><TD><TT>-7</TT></TD>
<TD>Аналогично <TT>-l 8 -b 4608 -r 6 -m -e</TT>.</TD></TR>

<TR><TD><TT>-8</TT></TD>
<TD>Аналогично <TT>-l 12 -b 4608 -r 6 -m -e</TT>.</TD></TR>

<TR><TD><TT>--fast</TT></TD>
<TD>Быстрейшее сжатие. Аналогично <TT>-0</TT>.</TD></TR>

<TR><TD><TT>--best</TT></TD>
<TD>Максимальное сжатие. Аналогично <TT>-8</TT>.</TD></TR>

<TR><TD><TT>-e</TT></TD>
<TD>Полный поиск модели (работает медленно!). Обычно кодер определяет лучшую модель и кодирует далее опираясь на нее. В данном режиме кодер будет создавать подфреймы всех порядков и использовать наименьший. Если максимальное значение порядка LPC велико, время кодирования существенно возрастет. Выигрыш обычно составляет около 0.5%.</TD></TR>

<TR><TD><TT>-E</TT></TD>
<TD>Использовать управляющие коды в кодере энтропии. Эта опция позволяет записывать незакодированное представление остатка в разделе, если его размер меньше. При этом время работы увеличивается, а уровень сжатия обычно улучшается примерно на 1%.</TD></TR>

<TR><TD><TT>-l #</TT></TD>
<TD>Определяет максимальный порядок LPC (коэффициентов линейного прогнозирования). Число должно быть меньше или равно <TT>32</TT>. Если значение равно <TT>0</TT>, кодер будет использовать вместо общего линейного прогнозирования постоянные коэффициенты. Этот метод увеличивает скорость работы, но файлы получаются на 5-10% больше.</TD></TR>

<TR><TD><TT>-q #</TT></TD>
<TD>Определяет точность дискретных коэффициентов линейного прогнозирования в битах. По умолчанию <TT>-q 0</TT>, что позволяет кодеру принимать решение в зависимости от сигнала. Лучше оставлять значение по умолчанию.</TD></TR>

<TR><TD><TT>-p</TT></TD>
<TD>Производить оптимизацию LPC. Переопределяет любую опцию <TT>-q</TT>. Сильно замедляет работу, и уменьшает размер файла на долю процента. <TT>-q</TT> не работает, когда используется <TT>-l 0</TT>.</TD></TR>

<TR><TD><TT>-r [#,]#</TT></TD>
<TD>Установить <I>[min,]max</I> порядок раздела. Если минимальное значение не указано, то оно устанавливается равным 0. По умолчанию кодер один параметр Райса для всего остатка подфрейма. Если использовать эту опцию, остаток будет разделяться на <I>2^min#</I> ... <I>2^max</I> частей, для каждой из которых будет определен собственный параметр Райса. С увеличением параметра <I>max</I> выигрыш будет все меньше. Наиболее оптимальный вариант достигается при использовании <TT>-r 2,2</TT> (и больших значений для больших размеров блоков). При этом сжатие обычно увеличивается на 1.5%. Выбор оптимального значения можно произвести по формуле <TT>размер_блока/(2^n)=128</TT>. Максимальный уровень сжатия достигается при использовании <TT>-r 0,16</TT>.</TD></TR>

<TR><TD><TT>-V</TT></TD>
<TD>Проверять процесс сжатия. В данном случае <B><TT>flac</TT></B> создает параллельный декодер, раскодирующий выход кодера и сравнивает результат с оригиналом. Если будет найдено несоответствие, кодирование прекратится. Время работы с этой опцией увеличивается, однако, при этом гарантируется, что файл будет правильно декодирован.</TD></TR>

<TR><TD>&nbsp;</TD>
<TD><TT>-F-</TT>, <TT>-S-</TT>, <TT>-P-</TT>, <TT>-m-</TT>, <TT>-e-</TT>, <TT>-E-</TT>, <TT>-p-</TT>, <TT>-V-</TT>, <TT>--lax-</TT>, <TT>--delete-input-file-</TT>, <TT>--sector-align-</TT> используются для отключения соответствующих опций.</TD></TR>
</TABLE>


<H4>Настройки формата</H4>
<TABLE border=1>

<TR><TD width=15%><TT>-fb | -fl</TT></TD>
<TD width=90%>Определяет порядок байтов в файле без заголовка big-endian | little-endian.</TD></TR>

<TR><TD><TT>-fc n</TT></TD>
<TD>Определяет количество каналов в файле без заголовка.</TD></TR>

<TR><TD><TT>-fp n</TT></TD>
<TD>Определяет количество бит на сэмпл в файле без заголовка.</TD></TR>

<TR><TD><TT>-fs n</TT></TD>
<TD>Определяет количество сэмплов в секунду в файле без заголовка.</TD></TR>

<TR><TD><TT>-fu</TT></TD>
<TD>Указывает, что сэмплы в файле без заголовка беззнаковые (по умолчанию знаковые).</TD></TR>

<TR><TD><TT>-fr</TT></TD>
<TD>Воспринимать входной (или выходной при декодировании) файл как raw поток сэмплов вне зависимости от суффикса.</TD></TR>
</TABLE>


<A NAME="metaflac">
<H3><B><TT>metaflac</TT></B></H3>

<P><B><TT>metaflac</TT></B> - это редактор метаданных, работающий из командной строки. Сейчас он только выводит содержимое блоков метаданных во .flac файле, но скоро с его помощью можно будет вставлять, удалять и редактировать блоки.</P>

<P>Cейчас <B><TT>metaflac</TT></B> вызывается только одним способом:</P>

<P><TT>metaflac [-v] входной_файл</TT></P>

<P>Входным_файлом может быть "-" для стандартного ввода (stdin). если использовать <TT>-v</TT>, будет получен более подробный отчет.</P>


<A NAME="plugins"><A NAME="xmms_plugin">
<H3>Плагин для XMMS</H3>

<P>Для его установки необходимо скопировать <TT>libxmms-flac.so</TT> в каталог, где находятся плагины ввода XMMS (обычно <TT>/usr/lib/xmms/Input</TT>). Больше ничего настраивать не надо. Для воспроизведения .flac файлов перезапустите XMMS.</P>

<A NAME="winamp_plugin2">
<H3>Плагин для Winamp</H3>

<P>Есть два плагина для Winamp: один для версий 2.x, а второй для 3.x. Если вы используете Winamp 2.x, то для установки плагина необходимо скопировать <TT>in_flac.dll</TT> в каталог, где находятся плагины ввода Winamp (обычно <TT>/Plugins</TT>). Больше ничего настраивать не надо. Для воспроизведения .flac файлов перезапустите Winamp.</P>

<A NAME="winamp_plugin3">
<H3>Плагин для Winamp</H3>

<P>Есть два плагина для Winamp: один для версий 2.x, а второй для 3.x. Если вы используете Winamp 3.x, то для установки плагина необходимо скопировать <TT>cnv_flacpcm.wac</TT> в каталог, где находятся плагины ввода Winamp (обычно <TT>/Wacs</TT>). Больше ничего настраивать не надо. Для воспроизведения .flac файлов перезапустите Winamp.</P>

<A NAME="libflac">
<H3><B><TT>libFLAC</TT></B></H3>

<P>Библиотека <B><TT>libFLAC</TT></B> является реализацией на C базового кодера и декодера. Используя эту библиотеку и написав немного кода, можно добавить поддержку FLAC в свою программу. Условия ее распространения - <A HREF="http://www.gnu.org/copyleft/lesser.html">LGPL</A>. Исходные тексты библиотеки <B><TT>libFLAC</TT></B>, также как и консольного кодека и плагинов, доступны, и могут послужить хорошим примером для использования.</P>

<P><B><TT>libFLAC</TT></B> требует стандартную и математическую библиотеки для языка C. Программные потоки не используются, однако, так как <B><TT>libFLAC</TT></B> не использует глобальные переменные, библиотека должна быть thread-safe.</P>

<P>Интерфейс <B><TT>libFLAC</TT></B> описан в публичных заголовочных файлах в каталоге include/FLAC. Для использования скомпилированной библиотеки нужны только публичные заголовки. Обратите внимание на то, что код из src/libFLAC/, включая защищенные заголовочные файлы из src/libFLAC/include/ не нужен.</P>

<P>В основном использование <B><TT>libFLAC</TT></B> состоит в следующем:</P>

<OL>
	<LI>Программа создает экземпляр кодера или декодера с помощью функций <TT>*_new()</TT>.</LI>
	
	<LI>Программа устанавливает параметры экземпляра и предоставляет ему обратные вызовы для чтения, записи, сообщения об ошибках и работы с метаданными с помощью функций <TT>*_set_*()</TT>.</LI>
	
	<LI>Программа инициализирует экземпляр, проверяет параметры и готовится к кодированию/декодированию, используя функции <TT>*_init()</TT>.</LI>
	
	<LI>Программа вызывает функции <TT>*_process_*()</TT> для кодирования или декодирования данных, которые в свою очередь делают обратные вызовы.</LI>
	
	<LI>Программа завершает работу экземпляра функцией <TT>*_finish()</TT>, которая сбрасывает буферы ввода и вывода.</LI>
	
	<LI>Экземпляр может быть использован снова либо удален функцией <TT>*_delete()</TT>.</LI>

</OL>

<P>Для декодирования <B><TT>libFLAC</TT></B> предоставляет три уровня доступа. На нижнем уровне находится декодер потоков, на следующем - декодер потоков с возможностью поиска, а на верхнем - декодер файлов. Интерфейсы описаны в файлах <TT>stream_decoder.h</TT>, <TT>seekable_stream_decoder.h</TT> и <TT>file_decoder.h</TT> соответственно. Использовать лучше всего декодер более верхнего уровня.</P>

<P>Потоковый декодер рассчитывает на обратные вызовы для получения входных и выходных данных. Декодер с возможностью поиска является оберткой потокового декодера, предоставляющий возможность поиска, однако для его выполнения вам необходимо добавить обратные вызовы. Файловый декодер сам осуществляет обратные вызовы для чтения и предоставляет функции поиска.</P>

<P>кодер пока что реализован только на потоковом уровне (<TT>stream_encoder.h</TT>).</P>

<P>Структуры и константы, относящиеся к формату, определены в файле <TT>format.h</TT>.</P>


<P><B>ДЕКОДЕР ПОТОКОВ</B></P>
 
<P>Сначала обсудим декодер потоков. Тип его экземпляра <TT>FLAC__StreamDecoder</TT>. Обычно в программе экземпляр создается вызовом <TT>FLAC__stream_decoder_new()</TT>, затем вызывает функции <TT>FLAC__stream_decoder_set_*()</TT> для установки обратных вызовов и пользовательских данных и инициализируется функцией <TT>FLAC__stream_decoder_init()</TT>. Необходимые обратные вызовы:</P>

<UL>
	<LI>Обратный вызов для чтения. Эта функция вызывается, когда декодеру необходимы данные. В качестве параметров передается адрес буфера, который нужно заполнить, и его размер в байтах. Обратный вызов может вернуть меньше данных и изменить счетчик байтов, но не должен переполнять буфер. Код возврата при выходе выбирается из <TT>FLAC__StreamDecoderReadStatus</TT>.</LI>

	<LI>Обратный вызов для записи. Эта функция вызывается после декодирования одного фрейма данных. Декодер передаст метаданные фрейма, а также массив указателей (по одному на каждый канал) на декодированные данные.</LI>

	<LI>Обратный вызов для работы с метаданными. Функция вызывается после разбора блока метаданных. Для потока всегда должен существовать блок метаданных <TT>STREAMINFO</TT>, за которым может следовать произвольное количество других блоков. Они будут возвращены декодером в том же порядке, в каком они расположены в потоке и всегда перед первым аудио фреймом. Переданный блок метаданных не должен изменяться и не сохраняется после обратного вызова, поэтому, если он будет нужен в дальнейшем сделайте его копию с помощью функции <TT>FLAC__metadata_object_copy()</TT>.</LI>

	<LI>Обратный вызов для сообщения об ошибке. Эта функция вызывается, если при декодировании происходит ошибка.</LI>
</UL>

<P>Когда декодер инициализирован, программа может вызвать одну из следующих функций для декодирования:</P>

<UL>
	<LI><B><TT>FLAC__stream_decoder_process_whole_stream()</TT></B> - Декодер начинает работу и продолжает обрабатывать поток пока функция обратного вызова чтения не передаст код <TT>FLAC__STREAM_DECODER_READ_END_OF_STREAM</TT> или <TT>FLAC__STREAM_DECODER_READ_ABORT</TT>.</LI>

	<LI><B><TT>FLAC__stream_decoder_process_metadata()</TT></B> - Декодер обрабатывает поток до первого аудио фрейма.</LI>
	
	<LI><B><TT>FLAC__stream_decoder_process_one_frame()</TT></B> - Декодеровать только один фрейм. Перед вызовом этой функции все метаданные должны быть обработаны.</LI>

	<LI><B><TT>FLAC__stream_decoder_process_remaining_frames()</TT></B> - Декодировать все оставшиеся фреймы.  Перед вызовом этой функции все метаданные должны быть обработаны. Перед вызовом этой фунции также может вызываться <TT>FLAC__stream_decoder_process_one_frame()</TT>.</LI>
</UL>

<P>Когда декодер заканчивает работу, экземпляр обрабатывается функцией <TT>FLAC__stream_decoder_finish()</TT>, которая проверяет состояние декодера и освобождает память. Затем экземпляр может быть удален функцией <TT>FLAC__stream_decoder_delete()</TT> или инициализирован заново для декодирования другого потока.</P>

<P>Обратите внимание на то, что потоковый декодер не имеет представления о позиции в потоке, он только преобразовывает данные. Чтобы осуществлять поиск в потоке функции обратного вызова могут только сбрасывать данные декодера функцией <TT>FLAC__stream_decoder_flush()</TT> и начинать подавать данные с новой позиции с помощью обратного вызова для чтения. Декодер файлов поступает именно так.</P>

<P><B>ДЕКОДЕР ПОТОКОВ С ВОЗМОЖНОСТЬЮ ПОИСКА</B></P>

<P>Декодер потоков с возможностью поиска является оберткой для стандартного декодера потоков. Тип его экземпляра - <TT>FLAC__SeekableStreamDecoder</TT>. К обраным вызовам декодера потоков для чтения, записи, работы с метаданными и обработки ошибок необходимо добавить еще следующие:</P>

<UL>
	<LI>Обратный вызов для поиска. Эта функция вызывается, когда декодеру нужно найти абсолютную позицию в потоке.</LI>
	<LI>Обратный вызов для определения текущей позиции. Эта функция вызывается, когда декодеру нужно узнать текущую позицию в потоке.</LI>
	<LI>Обратный вызов для определения размера потока. Функция вызывается, когда декодеру нужно узнать размер потока. Используемому алгоритму поиска требуется знать общий размер потока.</LI>
	<LI>Обратный вызов для определения конца потока. Функция вызывается, когда декодеру нужно знать, достиг ли он конца потока. Этого результата можно добиться, используя обратные вызовы для определения текущей позиции и общего размера, но такой способ может потребовать гораздо больше ресурсов.</LI>

<P>Поиск осущесвляется через метод <TT>FLAC__seekable_stream_decoder_seek_absolute()</TT>. В любой момент после инициализации пользовател может вызвать эту функцию для перехода к опрделенному сэмплу в потоке. Первый обратный вызов записи будет содержать (возможно, неполный) блок, начинающийся с заданного сэмпла.</P>

<P>Декодер потоков с возможностью поиска предоставляет проверку подписей MD5. Если ее включить перед инициализацией, функция <TT>FLAC__seekable_stream_decoder_finish()</TT> сообщит совпадает ли подпись MD5 декодированного потока с сохраненной блоке <TT>STREAMINFO</TT>. Проверка подписи MD5 автоматически отключается при попытке посика или если в блоке <TT>STREAMINFO</TT> не найдена подпись.</TT>

<P><B>ДЕКОДЕР ФАЙЛОВ</B></P>

<P>Декодер файлов - это оболочка декодера потоков с возможностью поиска, призванная упростить процесс декодирования файлов. Тип его экземпляра - <TT>FLAC__FileDecoder</TT>. Отличие от потокового декодера состоит в том, что вместо обратного вызова для чтения (который обрабатывает сам декодер) при инициализации указывается путь к файлу. Выполнение остальных функций декодер берет на себя.</P>

<P>Аналогично декодеру потоков с возможностью поиска он предоставляет поиск через метод <TT>FLAC__file_decoder_seek_absolute()</TT>. В любой момент после инициализации декодера файлов программа может вызвать эту функцию для поиска сэмпла в файле. Впоследствии, при первом обратном вызове для записи он будет содержать (возжожно неполный) блок, начинающийся с этого сэмпла.</P>

<P>От декодера потоков с возможностью поиска также наследуется проверка подписи MD5. Если эта возможность будет включена перед инициализацией, <TT>FLAC__file_decoder_finish()</TT> сообщит, если подпись MD5 распакованных данных не совпадет с сохраненной в блоке STREAMINFO. Проверка MD5 автоматически выключается, если в блоке STREAMINFO нет подписи или при попытке осуществления поиска.


<P><B>кодер ПОТОКОВ</B></P>

<P>кодер потоков работает аналогично декодеру, однако имеет меньше обратных вызовов и больше опций. Тип экземпляра - <TT>FLAC__StreamEncoder</TT>. Для создания нового экземпляра в программе нужно вызвать функцию <TT>FLAC__stream_encoder_new()</TT>, а чтобы проинициализировать его - <TT>FLAC__stream_encoder_init()</TT>.</P>

<P>В отличие от процесса декодирования кодирование в формат FLAC имеет множество опций, влияющих на скорость и уровень сжатия. Когда программа вызывает <TT>FLAC__stream_encoder_init()</TT>, кодер проверяет значения, поэтому необходимо убедиться, что возвращемое этой функцией значение - <TT>FLAC__STREAM_ENCODER_OK</TT>. Для установки параметров нужно иметь некоторое представление о формате (см. <A HREF="#format">описание формата для пользователя</A> или его <A HREF="format.html">формальное описание</A>). Список необходимых параметров приведен здесь:</P>

<UL>
    <LI><B><TT>streamable_subset</TT></B> - <TT>истина</TT>, если необходимо, чтобы выход соответствовал потоковому <A HREF="format.html#subset">подмножеству формата</A>, иначе <TT>ложь</TT>.</LI>

    <LI><B><TT>do_mid_side_stereo</TT></B> - <TT>истина</TT>, если нужно использовать усредненное кодирование для стерео потоков. Значение <TT>channels</TT> должно быть <TT>2</TT>.</LI>

    <LI><B><TT>loose_mid_side_stereo</TT></B> - <TT>истина</TT>, чтобы применить адаптивное переключение режима усредненного кодирования, иначе ложь. <TT>do_mid_side_stereo</TT> должно быть истина.</LI>

    <LI><B><TT>channels</TT></B> (количество каналов) - должно быть &lt;= <TT>FLAC__MAX_CHANNELS</TT>.</LI>

    <LI><B><TT>bits_per_sample</TT></B> - количество битов на сэмпл.</LI>

    <LI><B><TT>sample_rate</TT></B> (частота дискретизации) - должно быть &lt;= <TT>FLAC__MAX_SAMPLE_RATE</TT>.</LI>

    <LI><B><TT>blocksize</TT></B> (размер блока) - должен быть между <TT>FLAC__MIN_BLOCKSIZE</TT> и <TT>FLAC__MAX_BLOCKSIZE</TT>.</LI>

    <LI><B><TT>max_lpc_order</TT></B> (максимальный порядок коэффициентов линейного прогнозирования) - <TT>0</TT> указывает, что кодер не должен использовать LPC, а только постоянные предикторы. Должно быть &lt;= <TT>FLAC__MAX_LPC_ORDER</TT>.</LI>

    <LI><B><TT>qlp_coeff_precision</TT></B> - должно быть &gt;= <TT>FLAC__MIN_QLP_COEFF_PRECISION</TT>, или <TT>0</TT>, чтобы кодер мог выбирать коэффициенты в зависимости от размера блока. В текущей реализации сумма <TT>qlp_coeff_precision</TT>+<TT>bits_per_sample</TT> должна быть &lt; <TT>32</TT>.</LI>

    <LI><B><TT>do_qlp_coeff_prec_search</TT></B> - <TT>ложь</TT>, чтобы использовать заданное значение <TT>qlp_coeff_precision</TT>; <TT>истина</TT> для поиска и выбора лучшего значения <TT>qlp_coeff_precision</TT>.</LI>

	<LI><B><TT>do_escape_coding</TT></B> - истина, если нужно искать управляющий код на стадии кодирования энтропии для небольшого увеличения уровня сжатия.</LI>

    <LI><B><TT>do_exhaustive_model_search</TT></B> (производить полный поиск наилучшей модели) - <TT>ложь</TT>, to use estimated bits per residual for scoring; <TT>истина</TT> для перебора всех возможных вариантов и выбора наилучшего.</LI>

    <LI><B><TT>min_residual_partition_order</TT></B> (минимальный порядок раздела остатков), <B><TT>max_residual_partition_order</TT></B> (максимальный порядок раздела остатков)= <TT>0</TT>, чтобы оценивать параметр Райса основываясь на дисперсии остатков; &gt; <TT>0</TT> для разделения остатков и определения параметра для каждого раздела, основываясь на среднем. <TT>min_residual_partition_order</TT> и <TT>max_residual_partition_order</TT> определяют минимальный и максимальный порядок раздела Райса.</LI>

    <LI><B><TT>rice_parameter_search_dist</TT></B> (интервал для поиска параметра Райса) - <TT>0</TT>, чтобы использовать только вычисленный параметр <TT>k</TT>; иначе пытаться кодировать со всеми параметрами из интервала [<TT>k</TT>-<TT>rice_parameter_search_dist</TT>..<TT>k</TT>+<TT>rice_parameter_search_dist</TT>] и выбирать лучший вариант.</LI>

    <LI><B><TT>total_samples_estimate</TT></B> (количество сэмплов) - Может равняться <TT>0</TT>, если неизвестно. Иначе указывается количество сэмплов, которое нужно закодировать. Это позволяет создавать более точный блок <TT>STREAMINFO</TT> при первом же проходе в случае, когда кодер не может вернуться к началу вывода, чтобы обновить блок <TT>STREAMINFO</TT>.</LI>

    <LI><B><TT>seek_table</TT></B> (таблица для поиска) - создать необязательную таблицу для поиска в файле. <TT>NULL</TT> указывает, что таблица не нужна.</LI>

    <LI><B><TT>padding</TT></B> (резервирование места) - размер блока <TT>PADDING</TT> (следует за таблицей для поиска); <TT>-1</TT> означает, что блок <TT>PADDING</TT> добавлять не нужно. Помните, что указывается размер для данных; общий размер блока PADDING будет на 4 байта больше из-за заголовка.</LI>
</UL>

<P>Программа должна предоставить <TT>FLAC__stream_encoder_init()</TT> адреса для следующих обратных вызовов:</TT>

<UL>
    <LI>Обратный вызов для записи. Вызывается, когда появляются закодированные данные для записи. Это могут быть метаданные смешанные с аудио фреймами, причем не гарантируется, что данные будут выровнены на границу блока метаданных или фрейма.</LI>

    <LI>Обратный вызов для работы с метаданными. Вызывается однажды по завершении кодирования с populated структурой <TT>STREAMINFO</TT>. Это нужно для того, чтобы кодеры файлов могли вернуться к началу файла и записать в блок <TT>STREAMINFO</TT> корректные данные о кодировании, например минимальный и максимальный размер фрейма.</LI>
</UL>

<P>Вызов <TT>FLAC__stream_encoder_init()</TT> непосредственно производит обратный вызов для записи сигнатуры &quot;fLaC&quot; и всех определенных на данный момент метаданных.</P>

<P>После инициализации экземпляра программа может передавать данные кодеру двумя способами:</P>

<UL>
    <LI>Разделенными по каналам через <B><TT>FLAC__stream_encoder_process()</TT></B>. В этом случае нужно определить массив указателей на буфферы одинакового размера, по одному на каждый канал. Выравнивать сэмплы на границу блока не нужно.</LI>

    <LI>В чередующихся каналах через <B><TT>FLAC__stream_encoder_process_interleaved()</TT></B>. Программа должна передать один указатель на аудио данные с чередующимися каналами (например, <TT>канал0_сэмпл0, канал1_сэмпл0, ... , каналN_сэмпл0, канал0_сэмпл1, ...</TT>). Данные могут быть не выровнены на границу блока, но должны быть выровнены на границу сэмпла, т.е. первым значением должно быть <TT>канал0_сэмплX</TT>, а последним - <TT>каналN_сэмплY</TT>.</LI>
</UL>

<P>Для завершения кодирования данных программа вызывает функцию <TT>FLAC__stream_encoder_finish()</TT>, которая кодирует оставшиеся данные из входного потока и делает обратный вызов для работы с метаданными с корректной статистикой о процессе кодирования. Экземпляр может быть удален функцией <TT>FLAC__stream_encoder_delete()</TT> или инициализирован снова для кодирования нового потока.</P>


<P><B>РАЗНОЕ</B></P>

<P>Необходимо отметить, что когда передаются указатели на аудио данные, их порядок имеет значение только для стерео потоков. Канал <TT>0</TT> соответствует левому каналу, а <TT>1</TT> - правому.</P>


<P><B>МЕТАДАННЫЕ</B></P>

<P>Программы, записывающие свои блоки метаданных <TT>APPLICATION</TT>, могут указать кодеру, чтобы он записал блок метаданных <TT>PADDING</TT> нужного размера. В этом случае вместо перезаписи всего потока после кодирования программа сможет просто заменить блок <TT>PADDING</TT> на свой. Если известен только максимальный размер блока <TT>APPLICATION</TT>, программа может создать резервный блок чуть большего размера, а после кодирования разделить его на блоки <TT>APPLICATION</TT> и <TT>PADDING</TT>.</P>

<P>Если размер блока метаданных <TT>APPLICATION</TT> известен заранее, размер резервируемой области может быть легко вычеслен. Если размер блока <TT>APPLICATION</TT> (не включая заголовок блока) равен <TT>N</TT> байтам, то экземпляру FLAC__StreamEncoder перед инициализацией нужно передать значение <TT>N+4</TT>. Это нужно, чтобы учесть дополнительное место необходимое для хранения идентификатора приложения.</P>

<P>Когда известен только максимальный размер, скажем, <TT>N</TT> байт, нужно зарезервировать <TT>N+8</TT> байт. Четыре для ID приложения и четыре для дополнительного блока <TT>PADDING</TT>, который заполнит оставшееся пространство. По окончании кодирования, когда размер блока данных <TT>APPLICATION</TT> становится известной и равной, допустим, <TT>M</TT> байтам, на место первоначального блока <TT>PADDING</TT> будет записан блок <TT>APPLICATION</TT> и блок <TT>PADDING</TT> длиной <TT>N-M</TT> байтов.</P>


<A NAME="bugs">
<H3>Известные ошибки</H3>

<P>Отслеживание ошибок ведется на <A HREF="http://sourceforge.net/bugs/?group_id=13478">этой</A> странице проекта, находящейся на SourceForge. Если Вы будете сообщать об ошибке, пожалуйста, оставьте e-mail для контакта.</P>

<A NAME="monkey">
<H3>monkey</H3>

<P>Monkey's Audio поставляется с удобным пользовательским интерфейсом. Он поддерживает несколько внешних кодеров, в число которых не входит FLAC. Однако дистрибутив FLAC для Windows поставляется с утилитой, позволяющей заменить один из поддерживаемых внешних кодеков на FLAC. Это можно сделать так:</P>

<UL>
<LI>Скопируйте <B><TT>flac.exe</TT></B> и <B><TT>flac_ren.exe</TT></B> в каталог <B><TT>External/</TT></B> установки Monkey's Audio.</LI>

<LI>Выберите, какой поддерживаемый кодер заменить:
    <UL>
    <LI>Shorten - скопируйте <B><TT>flac_mac.exe</TT></B> поверх <B><TT>External/shortn32.exe</TT></B></LI>
    <LI>WavPack - скопируйте <B><TT>flac_mac.exe</TT></B> поверх <B><TT>External/wavpack.exe</TT></B> и <B><TT>External/wvunpack.exe</TT></B></LI>
    <LI>RKAU - скопируйте <B><TT>flac_mac.exe</TT></B> поверх <B><TT>External/rkau.exe</TT></B></LI>
    </UL>
Если выбрать WavPack, то для изменения опций FLAC будет доступно меню настройки WavPack Configuration.</LI>
<LI>Теперь можно кодировать в формат FLAC. Переименованный файл <B><TT>flac_mac.exe</TT></B> вызывает <B><TT>flac.exe</TT></B>, а затем <B><TT>flac_ren.exe</TT></B> для присвоения получаемому файлу расширения .flac.</LI>
</UL>
</P>

<P>Если вам нравится использовать оболочку Monkey's Audio GUI для получения файлов FLAC, попросите <A HREF="mailto:email@monkeysaudio.com">Мэта</A> (автора) добавить официальную поддержку FLAC! Другие оболочки можно использовать аналогичным образом. Если вы заитересованы в использовании какой-либо, пишите в список рассылки flac-dev.</P>

<P>&nbsp;Copyright (c) 2000,2001,2002 Josh Coalson</P>

</BODY>
</HTML>
